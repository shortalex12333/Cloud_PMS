## **action-router-service.md**

**CelesteOS — Backend Action Router (Dispatcher) Specification**

This document defines the **Action Router Service** — the dedicated backend component responsible for executing all user-initiated micro-actions generated by the Search Engine.

The frontend **never decides** how to execute actions.
The search engine provides structured actions → the frontend POSTs to the backend → the Action Router validates & dispatches to the correct workflow.

This keeps the system safe, deterministic, and extendable.

---

# ## 1. Purpose

The Action Router performs these functions:

1. **Receives micro-action executions from the frontend**
2. **Validates user JWT + yacht isolation**
3. **Validates action constraints** (role, required fields, entity presence)
4. **Validates payload** using action’s schema
5. **Dispatches action** to:

   * internal API handler
   * or corresponding n8n workflow
6. **Logs the action** (audit trail)
7. **Returns structured action result**

This abstracts mutation workflows away from the frontend and keeps logic centralized.

---

# ## 2. Architectural Position

```
Frontend Action Button
      ↓
POST /v1/actions/execute
      ↓
Action Router
      ↓
Validator → Role / Yacht / Schema
      ↓
Dispatcher
      ↓
n8n Workflow / Supabase RPC / Internal Handler
      ↓
Return Result
```

The Action Router is the **single gatekeeper** for all user-triggered actions.

---

# ## 3. API Contract

### **POST `/v1/actions/execute`**

#### Request Body

```json
{
  "action": "add_note",
  "context": {
    "yacht_id": "uuid",
    "equipment_id": "uuid"
  },
  "payload": {
    "note_text": "Leak found near coolant outlet."
  }
}
```

#### Response

```json
{
  "status": "success",
  "action": "add_note",
  "result": { "note_id": "uuid" }
}
```

---

# ## 4. Structure of the Router

```
action-router/
  router.py (or index.ts)
  registry.py
  validators/
    schema_validator.py
    role_validator.py
    yacht_validator.py
  dispatcher/
    n8n_dispatcher.py
    internal_handlers.py
  schemas/
    add_note.json
    create_work_order.json
    ...
  logs/
    action_logger.py
```

---

# ## 5. Action Registry

A **single file** defines all available actions.

Example:

```python
ACTION_REGISTRY = {
  "add_note": {
    "endpoint": "internal:add_note",
    "schema": "schemas/add_note.json",
    "roles": ["Engineer", "HOD"],
    "requires": ["equipment_id", "note_text"]
  },
  "create_work_order": {
    "endpoint": "n8n:create_work_order",
    "schema": "schemas/create_work_order.json",
    "roles": ["Engineer", "HOD"],
    "requires": ["equipment_id", "title"]
  },
  "add_document_to_handover": {
    "endpoint": "n8n:add_document",
    "schema": "schemas/add_to_handover.json",
    "roles": ["Engineer", "HOD"],
    "requires": ["document_id"]
  }
}
```

### Explanation:

* `endpoint` → either `internal:<function>` or `n8n:<workflow>`
* `schema` → JSON schema used to validate payload
* `roles` → allowed roles
* `requires` → required fields from `context` + `payload`

---

# ## 6. Validation Pipeline

When request hits `/v1/actions/execute`, router:

### **Step 1 — JWT Validation**

* Validate Supabase JWT
* Extract `auth_user_id`
* Lookup user → `yacht_id`, `role`

### **Step 2 — Yacht Isolation**

* Ensure `context.yacht_id == user.yacht_id`
* Reject cross-yacht access

### **Step 3 — Role Permission Check**

* Check if `user.role` ∈ `allowed_roles`

### **Step 4 — Required Field Check**

For an action like:

```
requires: ["equipment_id", "note_text"]
```

Ensure both exist in the combined:

```
finalPayload = { context, payload }
```

### **Step 5 — Schema Validation**

Validate `payload` using the JSON schema defined.

### **Step 6 — Dispatch**

If valid → hand off to dispatcher.

---

# ## 7. Dispatcher

Two dispatcher types exist.

---

## 7.1 Internal Dispatcher (Fast actions)

Some actions do not need n8n.

Examples:

* add note
* close work order
* update status
* generate signed document URL

Internal dispatcher calls functions defined in:

```
dispatcher/internal_handlers.py
```

Example handler:

```python
async def add_note(params):
    return supabase.table("notes").insert({
        "yacht_id": params["yacht_id"],
        "equipment_id": params["equipment_id"],
        "note_text": params["note_text"]
    }).execute()
```

---

## 7.2 n8n Dispatcher (Workflow actions)

More complex workflows (like create_work_order) use n8n:

```
POST https://n8n.yourdomain.com/webhook/<workflow-name>
{
  "yacht_id": "...",
  "equipment_id": "...",
  "title": "...",
  "description": "...",
  ...
}
```

Dispatcher:

```python
async def dispatch_to_n8n(action, params):
    url = f"{N8N_URL}/webhook/{action}"
    async with httpx.AsyncClient() as client:
        resp = await client.post(url, json=params)
    return resp.json()
```

---

# ## 8. Logging Layer

Every executed action is logged to:

### `action_logs` table

Fields:

* `action_id`
* `action_name`
* `yacht_id`
* `user_id`
* `payload`
* `timestamp`
* `status`
* `error_message`

This ensures accountability & traceability.

---

# ## 9. Error Handling

The router returns:

### **Validation Errors**

```
400 BAD REQUEST
{
  "status": "error",
  "error": "Missing required field: equipment_id"
}
```

### **Permission Errors**

```
403 FORBIDDEN
{
  "status": "error",
  "error": "User role 'ETO' cannot perform 'create_work_order'"
}
```

### **Dispatch Errors**

```
502 BAD GATEWAY
{
  "status": "error",
  "error": "n8n workflow failed"
}
```

---

# ## 10. Extending with New Actions

To add a new action:

1. Add entry to `ACTION_REGISTRY`
2. Create JSON schema in `/schemas/`
3. Add handler in `internal_handlers.py` or create n8n webhook
4. Search Engine can now output this action automatically

No frontend changes needed.

---

# ## 11. Example Action Lifecycle

User query:

> “add note to port stabilizer leak found”

### Step-by-step:

1. Search engine → detects intent `add_note`
2. Returns card with micro-action:

   ```
   action: add_note
   endpoint: /v1/actions/execute
   payload_template: {...}
   ```
3. Frontend → collects text → POST to `/v1/actions/execute`
4. Router → validates role, schema, yacht_id
5. Internal dispatcher inserts note into Supabase
6. Action logged
7. Returns `note_id` to frontend
8. Frontend updates UI instantly

---

# ## 12. Summary

The Action Router:

* Centralizes all mutation logic
* Enforces security (role & yacht isolation)
* Ensures payload accuracy (schemas)
* Enables dynamic micro-actions
* Passes execution to n8n or internal handlers
* Eliminates frontend guesswork
* Makes the system extensible with zero UI changes

It is the operational backbone connecting Search → User Intent → Actual Workflows.

---
