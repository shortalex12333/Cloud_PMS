{
  "name": "Predictive Recompute Equipment (MVP2)",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "internal/predictive-recompute",
        "responseMode": "responseNode",
        "options": {
          "responseHeaders": {
            "entries": [{ "name": "Content-Type", "value": "application/json" }]
          }
        }
      },
      "id": "webhook",
      "name": "POST /internal/predictive-recompute",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1.1,
      "position": [0, 300],
      "webhookId": "predictive-recompute"
    },
    {
      "parameters": {
        "jsCode": "// Extract and validate input\nconst body = $input.first().json.body || $input.first().json;\n\nreturn [{\n  json: {\n    equipment_id: body.equipment_id,\n    yacht_id: body.yacht_id,\n    event: body.event || 'manual',\n    event_category: body.event_category || 'manual',\n    signal_weight: body.signal_weight,\n    weight_delta: body.weight_delta || 0\n  }\n}];"
      },
      "id": "extract_input",
      "name": "Extract Input",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [220, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT id, yacht_id, name, system_type, manufacturer, criticality FROM equipment WHERE id = '{{ $json.equipment_id }}'",
        "options": {}
      },
      "id": "get_equipment",
      "name": "A. Get Equipment",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [440, 100],
      "credentials": {
        "postgres": { "id": "supabase_postgres", "name": "Supabase Postgres" }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT COUNT(*) as fault_count FROM faults WHERE equipment_id = '{{ $('Extract Input').item.json.equipment_id }}' AND detected_at > NOW() - INTERVAL '90 days'",
        "options": {}
      },
      "id": "get_faults",
      "name": "A. Get Faults (90d)",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [440, 250],
      "credentials": {
        "postgres": { "id": "supabase_postgres", "name": "Supabase Postgres" }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT COUNT(*) as wo_count, COUNT(*) FILTER (WHERE due_date < CURRENT_DATE AND status NOT IN ('completed', 'cancelled')) as overdue_count, COUNT(*) FILTER (WHERE type = 'corrective') as corrective_count FROM work_orders WHERE equipment_id = '{{ $('Extract Input').item.json.equipment_id }}' AND created_at > NOW() - INTERVAL '90 days'",
        "options": {}
      },
      "id": "get_work_orders",
      "name": "A. Get Work Orders (90d)",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [440, 400],
      "credentials": {
        "postgres": { "id": "supabase_postgres", "name": "Supabase Postgres" }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT COUNT(*) as note_count FROM notes WHERE equipment_id = '{{ $('Extract Input').item.json.equipment_id }}' AND created_at > NOW() - INTERVAL '90 days'",
        "options": {}
      },
      "id": "get_notes",
      "name": "A. Get Notes (90d)",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [440, 550],
      "credentials": {
        "postgres": { "id": "supabase_postgres", "name": "Supabase Postgres" }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT risk_score as old_risk_score, confidence as old_confidence, contributing_factors as old_factors FROM predictive_state WHERE equipment_id = '{{ $('Extract Input').item.json.equipment_id }}' AND yacht_id = '{{ $('Extract Input').item.json.yacht_id }}'",
        "options": {}
      },
      "id": "get_previous_state",
      "name": "D. Get Previous State",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [440, 700],
      "credentials": {
        "postgres": { "id": "supabase_postgres", "name": "Supabase Postgres" }
      }
    },
    {
      "parameters": {
        "mode": "combine",
        "mergeByFields": { "values": [] },
        "joinMode": "keepEverything",
        "outputDataFrom": "both",
        "options": {}
      },
      "id": "merge_data",
      "name": "Merge All Data",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2.1,
      "position": [700, 350]
    },
    {
      "parameters": {
        "jsCode": "// B & C: Calculate risk score from all signals\nconst items = $input.all();\nconst inputData = $('Extract Input').first().json;\n\n// Aggregate data from all queries\nlet equipment = {};\nlet faultCount = 0;\nlet woCount = 0;\nlet overdueCount = 0;\nlet correctiveCount = 0;\nlet noteCount = 0;\nlet oldRiskScore = 0;\nlet oldConfidence = 0;\nlet oldFactors = {};\n\nfor (const item of items) {\n  const d = item.json;\n  if (d.name) equipment = d;\n  if (d.fault_count !== undefined) faultCount = parseInt(d.fault_count) || 0;\n  if (d.wo_count !== undefined) {\n    woCount = parseInt(d.wo_count) || 0;\n    overdueCount = parseInt(d.overdue_count) || 0;\n    correctiveCount = parseInt(d.corrective_count) || 0;\n  }\n  if (d.note_count !== undefined) noteCount = parseInt(d.note_count) || 0;\n  if (d.old_risk_score !== undefined) {\n    oldRiskScore = parseFloat(d.old_risk_score) || 0;\n    oldConfidence = parseFloat(d.old_confidence) || 0;\n    oldFactors = typeof d.old_factors === 'string' ? JSON.parse(d.old_factors || '{}') : (d.old_factors || {});\n  }\n}\n\n// B: Calculate signals (0-1 normalized)\nconst faultSignal = Math.min(faultCount / 10, 1.0);\nconst woSignal = Math.min(overdueCount / 5, 1.0);\nconst notesSignal = Math.min(noteCount / 10, 1.0);\nconst correctiveSignal = Math.min(correctiveCount / 5, 1.0);\n\nconst criticality = equipment.criticality || 'low';\nconst criticalitySignal = criticality === 'high' ? 1.0 : criticality === 'medium' ? 0.5 : 0.2;\n\n// C: Compute weighted risk score\nconst riskScore = (\n  0.35 * faultSignal +\n  0.25 * woSignal +\n  0.15 * notesSignal +\n  0.15 * correctiveSignal +\n  0.10 * criticalitySignal\n);\n\n// Confidence based on data availability\nlet dataPoints = 0;\nif (faultCount > 0) dataPoints++;\nif (woCount > 0) dataPoints++;\nif (noteCount > 0) dataPoints++;\nconst confidence = Math.min((dataPoints + 1) / 4, 1.0);\n\n// Contributing factors\nconst contributingFactors = {\n  fault_signal: Math.round(faultSignal * 1000) / 1000,\n  work_order_signal: Math.round(woSignal * 1000) / 1000,\n  notes_signal: Math.round(notesSignal * 1000) / 1000,\n  corrective_signal: Math.round(correctiveSignal * 1000) / 1000,\n  criticality_signal: Math.round(criticalitySignal * 1000) / 1000,\n  fault_count: faultCount,\n  overdue_count: overdueCount,\n  note_count: noteCount,\n  corrective_count: correctiveCount\n};\n\n// F: Threshold crossing detection\nlet thresholdCrossed = null;\nlet severity = null;\n\nif (oldRiskScore < 0.75 && riskScore >= 0.75) {\n  thresholdCrossed = 'critical';\n  severity = 'critical';\n} else if (oldRiskScore < 0.60 && riskScore >= 0.60) {\n  thresholdCrossed = 'high';\n  severity = 'high';\n} else if (oldRiskScore < 0.45 && riskScore >= 0.45) {\n  thresholdCrossed = 'elevated';\n  severity = 'elevated';\n}\n\nreturn [{\n  json: {\n    equipment_id: inputData.equipment_id,\n    yacht_id: inputData.yacht_id,\n    equipment_name: equipment.name || 'Unknown',\n    event: inputData.event,\n    risk_score: Math.round(riskScore * 10000) / 10000,\n    old_risk_score: oldRiskScore,\n    confidence: Math.round(confidence * 1000) / 1000,\n    contributing_factors: JSON.stringify(contributingFactors),\n    last_calculated_at: new Date().toISOString(),\n    threshold_crossed: thresholdCrossed,\n    severity: severity\n  }\n}];"
      },
      "id": "calculate_risk",
      "name": "B/C. Calculate Risk Score",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [920, 350]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO predictive_state (yacht_id, equipment_id, risk_score, confidence, contributing_factors, last_calculated_at, updated_at) VALUES ('{{ $json.yacht_id }}', '{{ $json.equipment_id }}', {{ $json.risk_score }}, {{ $json.confidence }}, '{{ $json.contributing_factors }}'::jsonb, '{{ $json.last_calculated_at }}', NOW()) ON CONFLICT (yacht_id, equipment_id) DO UPDATE SET risk_score = EXCLUDED.risk_score, confidence = EXCLUDED.confidence, contributing_factors = EXCLUDED.contributing_factors, last_calculated_at = EXCLUDED.last_calculated_at, updated_at = NOW() RETURNING id",
        "options": {}
      },
      "id": "upsert_state",
      "name": "E. UPSERT predictive_state",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [1140, 350],
      "credentials": {
        "postgres": { "id": "supabase_postgres", "name": "Supabase Postgres" }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": { "caseSensitive": true, "leftValue": "", "typeValidation": "strict" },
          "conditions": [
            {
              "id": "threshold_check",
              "leftValue": "={{ $('B/C. Calculate Risk Score').item.json.threshold_crossed }}",
              "rightValue": "",
              "operator": { "type": "string", "operation": "notEmpty" }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check_threshold",
      "name": "F. Threshold Crossed?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1360, 350]
    },
    {
      "parameters": {
        "jsCode": "// G: Generate insight for threshold crossing\nconst data = $('B/C. Calculate Risk Score').first().json;\nconst factors = JSON.parse(data.contributing_factors);\n\n// Build description\nconst issues = [];\nif (factors.fault_signal > 0.5) issues.push('high fault frequency');\nif (factors.work_order_signal > 0.5) issues.push('overdue maintenance tasks');\nif (factors.notes_signal > 0.5) issues.push('frequent crew concerns');\nif (factors.corrective_signal > 0.5) issues.push('recurring repairs');\n\nconst description = issues.length > 0 \n  ? `Risk threshold crossed. Contributing factors: ${issues.join(', ')}.`\n  : 'Risk threshold crossed due to multiple minor indicators.';\n\nconst recommendation = data.severity === 'critical'\n  ? 'Immediate inspection required. Check fault history and schedule maintenance.'\n  : data.severity === 'high'\n    ? 'Schedule inspection within 48 hours. Review recent work orders.'\n    : 'Monitor closely. Consider preventive inspection.';\n\nreturn [{\n  json: {\n    yacht_id: data.yacht_id,\n    equipment_id: data.equipment_id,\n    equipment_name: data.equipment_name,\n    insight_type: 'threshold_alert',\n    title: `${data.equipment_name} - ${data.severity.toUpperCase()} Risk Alert`,\n    description: description,\n    recommendation: recommendation,\n    severity: data.severity,\n    metadata: data.contributing_factors,\n    risk_score: data.risk_score,\n    old_risk_score: data.old_risk_score,\n    event_trigger: data.event\n  }\n}];"
      },
      "id": "generate_insight",
      "name": "G. Generate Insight",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1580, 250]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO predictive_insights (yacht_id, equipment_id, insight_type, title, description, recommendation, severity, metadata, created_at) VALUES ('{{ $json.yacht_id }}', '{{ $json.equipment_id }}', '{{ $json.insight_type }}', '{{ $json.title }}', '{{ $json.description }}', '{{ $json.recommendation }}', '{{ $json.severity }}', '{{ $json.metadata }}'::jsonb, NOW()) RETURNING id",
        "options": {}
      },
      "id": "insert_insight",
      "name": "G. Insert Insight",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [1800, 250],
      "credentials": {
        "postgres": { "id": "supabase_postgres", "name": "Supabase Postgres" }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.N8N_WEBHOOK_URL || 'https://api.celeste7.ai/webhook' }}/internal/micro-action-dispatch",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            { "name": "insight_id", "value": "={{ $json.id }}" },
            { "name": "equipment_id", "value": "={{ $('G. Generate Insight').item.json.equipment_id }}" },
            { "name": "yacht_id", "value": "={{ $('G. Generate Insight').item.json.yacht_id }}" },
            { "name": "severity", "value": "={{ $('G. Generate Insight').item.json.severity }}" },
            { "name": "equipment_name", "value": "={{ $('G. Generate Insight').item.json.equipment_name }}" },
            { "name": "title", "value": "={{ $('G. Generate Insight').item.json.title }}" }
          ]
        },
        "options": { "timeout": 10000 }
      },
      "id": "call_dispatcher",
      "name": "H. Call Micro-Action Dispatcher",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [2020, 250]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({ success: true, equipment_id: $('B/C. Calculate Risk Score').item.json.equipment_id, risk_score: $('B/C. Calculate Risk Score').item.json.risk_score, threshold_crossed: $('B/C. Calculate Risk Score').item.json.threshold_crossed || null, insight_generated: true }) }}"
      },
      "id": "respond_with_insight",
      "name": "Respond (With Insight)",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [2240, 250]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({ success: true, equipment_id: $('B/C. Calculate Risk Score').item.json.equipment_id, risk_score: $('B/C. Calculate Risk Score').item.json.risk_score, threshold_crossed: null, insight_generated: false }) }}"
      },
      "id": "respond_no_insight",
      "name": "Respond (No Insight)",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1580, 450]
    }
  ],
  "connections": {
    "POST /internal/predictive-recompute": {
      "main": [[{ "node": "Extract Input", "type": "main", "index": 0 }]]
    },
    "Extract Input": {
      "main": [[
        { "node": "A. Get Equipment", "type": "main", "index": 0 },
        { "node": "A. Get Faults (90d)", "type": "main", "index": 0 },
        { "node": "A. Get Work Orders (90d)", "type": "main", "index": 0 },
        { "node": "A. Get Notes (90d)", "type": "main", "index": 0 },
        { "node": "D. Get Previous State", "type": "main", "index": 0 }
      ]]
    },
    "A. Get Equipment": {
      "main": [[{ "node": "Merge All Data", "type": "main", "index": 0 }]]
    },
    "A. Get Faults (90d)": {
      "main": [[{ "node": "Merge All Data", "type": "main", "index": 0 }]]
    },
    "A. Get Work Orders (90d)": {
      "main": [[{ "node": "Merge All Data", "type": "main", "index": 0 }]]
    },
    "A. Get Notes (90d)": {
      "main": [[{ "node": "Merge All Data", "type": "main", "index": 0 }]]
    },
    "D. Get Previous State": {
      "main": [[{ "node": "Merge All Data", "type": "main", "index": 0 }]]
    },
    "Merge All Data": {
      "main": [[{ "node": "B/C. Calculate Risk Score", "type": "main", "index": 0 }]]
    },
    "B/C. Calculate Risk Score": {
      "main": [[{ "node": "E. UPSERT predictive_state", "type": "main", "index": 0 }]]
    },
    "E. UPSERT predictive_state": {
      "main": [[{ "node": "F. Threshold Crossed?", "type": "main", "index": 0 }]]
    },
    "F. Threshold Crossed?": {
      "main": [
        [{ "node": "G. Generate Insight", "type": "main", "index": 0 }],
        [{ "node": "Respond (No Insight)", "type": "main", "index": 0 }]
      ]
    },
    "G. Generate Insight": {
      "main": [[{ "node": "G. Insert Insight", "type": "main", "index": 0 }]]
    },
    "G. Insert Insight": {
      "main": [[{ "node": "H. Call Micro-Action Dispatcher", "type": "main", "index": 0 }]]
    },
    "H. Call Micro-Action Dispatcher": {
      "main": [[{ "node": "Respond (With Insight)", "type": "main", "index": 0 }]]
    }
  },
  "settings": { "executionOrder": "v1" },
  "staticData": null,
  "tags": ["predictive", "mvp2", "event-driven"],
  "triggerCount": 0,
  "versionId": "1"
}
