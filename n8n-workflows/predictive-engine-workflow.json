{
  "name": "Predictive Maintenance Engine (Fixed)",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "hours",
              "hoursInterval": 6
            }
          ]
        }
      },
      "id": "trigger",
      "name": "Every 6 Hours",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.1,
      "position": [0, 0]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT id, yacht_id, name, system_type, manufacturer, criticality FROM equipment WHERE yacht_id IS NOT NULL",
        "options": {}
      },
      "id": "get_equipment",
      "name": "Get All Equipment",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [220, 0],
      "credentials": {
        "postgres": {
          "id": "supabase_postgres",
          "name": "Supabase Postgres"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT equipment_id, COUNT(*) as fault_count, MAX(detected_at) as last_fault, array_agg(DISTINCT fault_code) as fault_codes FROM faults WHERE detected_at > NOW() - INTERVAL '90 days' GROUP BY equipment_id",
        "options": {}
      },
      "id": "get_faults",
      "name": "Get Fault Stats",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [220, 200],
      "credentials": {
        "postgres": {
          "id": "supabase_postgres",
          "name": "Supabase Postgres"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT equipment_id, COUNT(*) as wo_count, COUNT(*) FILTER (WHERE due_date < CURRENT_DATE AND status NOT IN ('completed', 'cancelled')) as overdue_count, COUNT(*) FILTER (WHERE type = 'corrective') as corrective_count FROM work_orders WHERE created_at > NOW() - INTERVAL '90 days' GROUP BY equipment_id",
        "options": {}
      },
      "id": "get_work_orders",
      "name": "Get Work Order Stats",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [220, 400],
      "credentials": {
        "postgres": {
          "id": "supabase_postgres",
          "name": "Supabase Postgres"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT equipment_id, COUNT(*) as note_count FROM notes WHERE equipment_id IS NOT NULL AND created_at > NOW() - INTERVAL '90 days' GROUP BY equipment_id",
        "options": {}
      },
      "id": "get_notes",
      "name": "Get Notes Stats",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [220, 600],
      "credentials": {
        "postgres": {
          "id": "supabase_postgres",
          "name": "Supabase Postgres"
        }
      }
    },
    {
      "parameters": {
        "mode": "combine",
        "mergeByFields": {
          "values": [
            {
              "field1": "id",
              "field2": "equipment_id"
            }
          ]
        },
        "joinMode": "keepEverything",
        "outputDataFrom": "both",
        "options": {}
      },
      "id": "merge_faults",
      "name": "Merge Faults",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2.1,
      "position": [500, 100]
    },
    {
      "parameters": {
        "mode": "combine",
        "mergeByFields": {
          "values": [
            {
              "field1": "id",
              "field2": "equipment_id"
            }
          ]
        },
        "joinMode": "keepEverything",
        "outputDataFrom": "both",
        "options": {}
      },
      "id": "merge_wo",
      "name": "Merge Work Orders",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2.1,
      "position": [720, 200]
    },
    {
      "parameters": {
        "mode": "combine",
        "mergeByFields": {
          "values": [
            {
              "field1": "id",
              "field2": "equipment_id"
            }
          ]
        },
        "joinMode": "keepEverything",
        "outputDataFrom": "both",
        "options": {}
      },
      "id": "merge_notes",
      "name": "Merge Notes",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2.1,
      "position": [940, 300]
    },
    {
      "parameters": {
        "jsCode": "// Calculate risk score for each equipment\n// Uses ACTUAL predictive_state columns from Supabase\n\nconst results = [];\n\nfor (const item of $input.all()) {\n  const data = item.json;\n  \n  // Normalize signals (0-1)\n  const faultCount = parseInt(data.fault_count) || 0;\n  const faultSignal = Math.min(faultCount / 10, 1.0);\n  \n  const overdueCount = parseInt(data.overdue_count) || 0;\n  const woSignal = Math.min(overdueCount / 5, 1.0);\n  \n  const noteCount = parseInt(data.note_count) || 0;\n  const notesSignal = Math.min(noteCount / 10, 1.0);\n  \n  const correctiveCount = parseInt(data.corrective_count) || 0;\n  const correctiveSignal = Math.min(correctiveCount / 5, 1.0);\n  \n  const criticality = data.criticality || 'low';\n  const criticalitySignal = criticality === 'high' ? 1.0 : \n                            criticality === 'medium' ? 0.5 : 0.2;\n  \n  // Calculate weighted risk score\n  const riskScore = (\n    0.35 * faultSignal +\n    0.25 * woSignal +\n    0.15 * notesSignal +\n    0.15 * correctiveSignal +\n    0.10 * criticalitySignal\n  );\n  \n  // Confidence based on data availability\n  let dataPoints = 0;\n  if (faultCount > 0) dataPoints++;\n  if (overdueCount > 0 || parseInt(data.wo_count) > 0) dataPoints++;\n  if (noteCount > 0) dataPoints++;\n  const confidence = Math.min(dataPoints / 3, 1.0);\n  \n  // contributing_factors as JSONB (matches actual schema)\n  const contributingFactors = {\n    fault_signal: Math.round(faultSignal * 1000) / 1000,\n    work_order_signal: Math.round(woSignal * 1000) / 1000,\n    notes_signal: Math.round(notesSignal * 1000) / 1000,\n    corrective_signal: Math.round(correctiveSignal * 1000) / 1000,\n    criticality_signal: Math.round(criticalitySignal * 1000) / 1000,\n    fault_count: faultCount,\n    overdue_count: overdueCount,\n    note_count: noteCount\n  };\n  \n  results.push({\n    json: {\n      yacht_id: data.yacht_id,\n      equipment_id: data.id,\n      equipment_name: data.name,\n      risk_score: Math.round(riskScore * 10000) / 10000,\n      confidence: Math.round(confidence * 1000) / 1000,\n      contributing_factors: JSON.stringify(contributingFactors),\n      last_calculated_at: new Date().toISOString()\n    }\n  });\n}\n\nreturn results;"
      },
      "id": "calculate_risk",
      "name": "Calculate Risk Scores",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1160, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO predictive_state (yacht_id, equipment_id, risk_score, confidence, contributing_factors, last_calculated_at, updated_at) VALUES ('{{ $json.yacht_id }}', '{{ $json.equipment_id }}', {{ $json.risk_score }}, {{ $json.confidence }}, '{{ $json.contributing_factors }}'::jsonb, '{{ $json.last_calculated_at }}', NOW()) ON CONFLICT (yacht_id, equipment_id) DO UPDATE SET risk_score = EXCLUDED.risk_score, confidence = EXCLUDED.confidence, contributing_factors = EXCLUDED.contributing_factors, last_calculated_at = EXCLUDED.last_calculated_at, updated_at = NOW()",
        "options": {}
      },
      "id": "save_risk",
      "name": "Save to predictive_state",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [1380, 300],
      "credentials": {
        "postgres": {
          "id": "supabase_postgres",
          "name": "Supabase Postgres"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "high_risk",
              "leftValue": "={{ $json.risk_score }}",
              "rightValue": 0.6,
              "operator": {
                "type": "number",
                "operation": "gte"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "filter_high_risk",
      "name": "Filter High Risk",
      "type": "n8n-nodes-base.filter",
      "typeVersion": 2,
      "position": [1600, 300]
    },
    {
      "parameters": {
        "jsCode": "// Generate insights using ACTUAL predictive_insights columns\n\nconst insights = [];\n\nfor (const item of $input.all()) {\n  const data = item.json;\n  const factors = JSON.parse(data.contributing_factors);\n  \n  let severity = 'medium';\n  if (data.risk_score >= 0.75) severity = 'critical';\n  else if (data.risk_score >= 0.6) severity = 'high';\n  \n  // Build description based on signals\n  const issues = [];\n  if (factors.fault_signal > 0.5) issues.push('high fault frequency');\n  if (factors.work_order_signal > 0.5) issues.push('overdue maintenance tasks');\n  if (factors.notes_signal > 0.5) issues.push('frequent crew notes');\n  \n  const description = issues.length > 0 \n    ? `Contributing factors: ${issues.join(', ')}.`\n    : 'Multiple minor indicators combined.';\n  \n  insights.push({\n    json: {\n      yacht_id: data.yacht_id,\n      equipment_id: data.equipment_id,\n      insight_type: 'risk_alert',\n      title: `${data.equipment_name} - Elevated Risk`,\n      description: description,\n      recommendation: 'Schedule inspection and review recent fault history',\n      severity: severity,\n      metadata: data.contributing_factors\n    }\n  });\n}\n\nreturn insights;"
      },
      "id": "generate_insights",
      "name": "Generate Insights",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1820, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO predictive_insights (yacht_id, equipment_id, insight_type, title, description, recommendation, severity, metadata) VALUES ('{{ $json.yacht_id }}', '{{ $json.equipment_id }}', '{{ $json.insight_type }}', '{{ $json.title }}', '{{ $json.description }}', '{{ $json.recommendation }}', '{{ $json.severity }}', '{{ $json.metadata }}'::jsonb)",
        "options": {}
      },
      "id": "save_insights",
      "name": "Save Insights",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [2040, 300],
      "credentials": {
        "postgres": {
          "id": "supabase_postgres",
          "name": "Supabase Postgres"
        }
      }
    }
  ],
  "connections": {
    "Every 6 Hours": {
      "main": [
        [
          { "node": "Get All Equipment", "type": "main", "index": 0 },
          { "node": "Get Fault Stats", "type": "main", "index": 0 },
          { "node": "Get Work Order Stats", "type": "main", "index": 0 },
          { "node": "Get Notes Stats", "type": "main", "index": 0 }
        ]
      ]
    },
    "Get All Equipment": {
      "main": [
        [
          { "node": "Merge Faults", "type": "main", "index": 0 }
        ]
      ]
    },
    "Get Fault Stats": {
      "main": [
        [
          { "node": "Merge Faults", "type": "main", "index": 1 }
        ]
      ]
    },
    "Merge Faults": {
      "main": [
        [
          { "node": "Merge Work Orders", "type": "main", "index": 0 }
        ]
      ]
    },
    "Get Work Order Stats": {
      "main": [
        [
          { "node": "Merge Work Orders", "type": "main", "index": 1 }
        ]
      ]
    },
    "Merge Work Orders": {
      "main": [
        [
          { "node": "Merge Notes", "type": "main", "index": 0 }
        ]
      ]
    },
    "Get Notes Stats": {
      "main": [
        [
          { "node": "Merge Notes", "type": "main", "index": 1 }
        ]
      ]
    },
    "Merge Notes": {
      "main": [
        [
          { "node": "Calculate Risk Scores", "type": "main", "index": 0 }
        ]
      ]
    },
    "Calculate Risk Scores": {
      "main": [
        [
          { "node": "Save to predictive_state", "type": "main", "index": 0 }
        ]
      ]
    },
    "Save to predictive_state": {
      "main": [
        [
          { "node": "Filter High Risk", "type": "main", "index": 0 }
        ]
      ]
    },
    "Filter High Risk": {
      "main": [
        [
          { "node": "Generate Insights", "type": "main", "index": 0 }
        ]
      ]
    },
    "Generate Insights": {
      "main": [
        [
          { "node": "Save Insights", "type": "main", "index": 0 }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 0,
  "updatedAt": "2024-01-01T00:00:00.000Z",
  "versionId": "2"
}
