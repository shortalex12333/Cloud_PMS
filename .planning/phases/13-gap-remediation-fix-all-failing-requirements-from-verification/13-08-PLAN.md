---
phase: 13-gap-remediation
plan: 08
type: execute
wave: 2
depends_on:
  - 13-06
files_modified:
  - tests/e2e/handover_signature_flow.spec.ts
  - apps/api/test_handover_roles.py
autonomous: true
requirements:
  - HAND-03

must_haves:
  truths:
    - "Handover role tests verify crew, HOD, and captain permissions"
    - "Signature display test confirms signature data renders"
    - "E2E test covers full handover sign-off workflow"
  artifacts:
    - path: "tests/e2e/handover_signature_flow.spec.ts"
      provides: "Handover signature E2E tests"
      min_lines: 80
    - path: "apps/api/test_handover_roles.py"
      provides: "Backend role permission tests for handover"
      min_lines: 100
  key_links:
    - from: "handover_signature_flow.spec.ts"
      to: "FinalizeHandoverModal"
      via: "SignaturePrompt rendering"
      pattern: "signature-prompt|sign-btn"
---

<objective>
Complete handover role tests and signature flow E2E tests.

Purpose: Complete HAND-03 verification gap - handover role tests are partial.
Output: E2E signature flow tests and backend role permission tests.
</objective>

<execution_context>
@/Users/celeste7/.claude/get-shit-done/workflows/execute-plan.md
@/Users/celeste7/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@apps/api/handlers/handover_handlers.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create handover signature flow E2E tests</name>
  <files>tests/e2e/handover_signature_flow.spec.ts</files>
  <action>
Create handover_signature_flow.spec.ts for signature display and workflow testing:

```typescript
import { test, expect } from '@playwright/test';
import { createAuthenticatedPage } from '../helpers/auth';

test.describe('Handover Signature Flow', () => {
  test.describe('Signature Display', () => {
    test('Finalized handover displays outgoing signature', async ({ browser }) => {
      const { page, cleanup } = await createAuthenticatedPage(browser, 'hod');

      await page.goto('/handovers/test-finalized-handover-id');

      // Verify signature section is visible
      await expect(page.locator('[data-testid="outgoing-signature"]')).toBeVisible();

      // Verify signature data is displayed
      await expect(page.locator('[data-testid="signature-name"]')).toContainText(/\w+/);
      await expect(page.locator('[data-testid="signature-date"]')).toBeVisible();

      await cleanup();
    });

    test('Completed handover displays both signatures', async ({ browser }) => {
      const { page, cleanup } = await createAuthenticatedPage(browser, 'hod');

      await page.goto('/handovers/test-completed-handover-id');

      // Both signatures visible
      await expect(page.locator('[data-testid="outgoing-signature"]')).toBeVisible();
      await expect(page.locator('[data-testid="incoming-signature"]')).toBeVisible();

      await cleanup();
    });
  });

  test.describe('Finalize Flow', () => {
    test('HOD can finalize handover with signature', async ({ browser }) => {
      const { page, cleanup } = await createAuthenticatedPage(browser, 'hod');

      await page.goto('/handovers/test-draft-handover-id');

      // Click finalize button
      await page.click('[data-testid="finalize-handover-btn"]');

      // Modal opens
      await expect(page.locator('[data-testid="finalize-modal"]')).toBeVisible();

      // Click finalize & sign
      await page.click('[data-testid="finalize-sign-btn"]');

      // Signature prompt appears
      await expect(page.locator('[data-testid="signature-prompt"]')).toBeVisible();

      // Verify mutation preview shows
      await expect(page.locator('[data-testid="mutation-preview"]')).toBeVisible();

      // Sign
      await page.click('[data-testid="sign-btn"]');

      // Success
      await expect(page.locator('text=Handover finalized')).toBeVisible();

      await cleanup();
    });

    test('Signature prompt shows correct user name', async ({ browser }) => {
      const { page, cleanup } = await createAuthenticatedPage(browser, 'hod');

      await page.goto('/handovers/test-draft-handover-id');
      await page.click('[data-testid="finalize-handover-btn"]');
      await page.click('[data-testid="finalize-sign-btn"]');

      // Verify user name in signature prompt
      await expect(page.locator('[data-testid="signature-prompt"]')).toContainText('Sign as');

      await cleanup();
    });

    test('Cancel button dismisses signature prompt', async ({ browser }) => {
      const { page, cleanup } = await createAuthenticatedPage(browser, 'hod');

      await page.goto('/handovers/test-draft-handover-id');
      await page.click('[data-testid="finalize-handover-btn"]');
      await page.click('[data-testid="finalize-sign-btn"]');

      // Cancel
      await page.click('[data-testid="cancel-btn"]');

      // Signature prompt dismissed
      await expect(page.locator('[data-testid="signature-prompt"]')).not.toBeVisible();

      await cleanup();
    });
  });

  test.describe('Sign-Off Flow', () => {
    test('Incoming officer can sign-off on handover', async ({ browser }) => {
      const { page, cleanup } = await createAuthenticatedPage(browser, 'hod');

      await page.goto('/handovers/test-finalized-handover-id');

      // Sign-off button visible
      await page.click('[data-testid="sign-off-incoming-btn"]');

      // Signature prompt
      await expect(page.locator('[data-testid="signature-prompt"]')).toBeVisible();

      await page.click('[data-testid="sign-btn"]');

      await expect(page.locator('text=Handover complete')).toBeVisible();

      await cleanup();
    });
  });

  test.describe('Export with Signatures', () => {
    test('Export includes signature data', async ({ browser }) => {
      const { page, cleanup } = await createAuthenticatedPage(browser, 'hod');

      await page.goto('/handovers/test-completed-handover-id');

      // Click export
      await page.click('[data-testid="export-handover-btn"]');

      // Verify export options include signature
      await expect(page.locator('text=Include signatures')).toBeVisible();

      await cleanup();
    });
  });
});
```
  </action>
  <verify>
File exists: `ls -la tests/e2e/handover_signature_flow.spec.ts`
Test count: `grep -c "test\\(" tests/e2e/handover_signature_flow.spec.ts`
  </verify>
  <done>handover_signature_flow.spec.ts exists with signature display and workflow tests.</done>
</task>

<task type="auto">
  <name>Task 2: Create handover role permission tests</name>
  <files>apps/api/test_handover_roles.py</files>
  <action>
Create test_handover_roles.py for backend role permission testing:

```python
"""
Handover Role Permission Tests
==============================

Tests for HAND-03: Backend handler tests pass for all user roles.

Covers:
- add_to_handover (crew, HOD, captain)
- edit_handover_item (HOD, captain)
- validate_handover (HOD, captain)
- finalize_handover (HOD, captain)
- export_handover (all roles)
- sign_outgoing (HOD, captain)
- sign_incoming (HOD, captain)
"""

import pytest
from unittest.mock import MagicMock, AsyncMock, patch
from datetime import datetime, timezone
import uuid

# Import handlers
import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).parent))
from handlers.handover_handlers import HandoverHandlers


@pytest.fixture
def mock_db():
    """Create mock Supabase client."""
    db = MagicMock()
    db.table = MagicMock(return_value=db)
    db.select = MagicMock(return_value=db)
    db.insert = MagicMock(return_value=db)
    db.update = MagicMock(return_value=db)
    db.eq = MagicMock(return_value=db)
    db.maybe_single = MagicMock(return_value=db)
    db.execute = MagicMock(return_value=MagicMock(data=[{"id": str(uuid.uuid4())}]))
    return db


@pytest.fixture
def handlers(mock_db):
    """Create handler instance."""
    return HandoverHandlers(mock_db)


class TestAddToHandover:
    """Tests for add_to_handover action."""

    @pytest.mark.asyncio
    async def test_crew_can_add_to_handover(self, handlers, mock_db):
        """Crew role can add items to handover."""
        mock_db.execute.return_value = MagicMock(data=[{
            "id": str(uuid.uuid4()),
            "title": "Test Item",
            "category": "general",
        }])

        result = await handlers.add_to_handover(
            yacht_id="test-yacht-id",
            user_id="crew-user-id",
            title="Test Handover Item",
            summary_text="Test summary",
            category="general",
            priority="normal",
        )

        assert result["status"] == "success"
        assert result["action"] == "add_to_handover"

    @pytest.mark.asyncio
    async def test_hod_can_add_to_handover(self, handlers, mock_db):
        """HOD role can add items to handover."""
        mock_db.execute.return_value = MagicMock(data=[{
            "id": str(uuid.uuid4()),
            "title": "Test Item",
            "category": "ongoing_fault",
        }])

        result = await handlers.add_to_handover(
            yacht_id="test-yacht-id",
            user_id="hod-user-id",
            title="Fault Handover",
            summary_text="Fault details",
            category="ongoing_fault",
            priority="high",
        )

        assert result["status"] == "success"

    @pytest.mark.asyncio
    async def test_captain_can_add_to_handover(self, handlers, mock_db):
        """Captain role can add items to handover."""
        mock_db.execute.return_value = MagicMock(data=[{
            "id": str(uuid.uuid4()),
            "title": "Captain Note",
            "category": "important_info",
        }])

        result = await handlers.add_to_handover(
            yacht_id="test-yacht-id",
            user_id="captain-user-id",
            title="Important Notice",
            summary_text="Captain's note",
            category="important_info",
            priority="high",
        )

        assert result["status"] == "success"


class TestEditHandoverItem:
    """Tests for edit_handover_item action."""

    @pytest.mark.asyncio
    async def test_hod_can_edit_handover_item(self, handlers, mock_db):
        """HOD can edit handover items."""
        item_id = str(uuid.uuid4())
        mock_db.execute.return_value = MagicMock(data=[{
            "id": item_id,
            "title": "Updated Item",
        }])

        result = await handlers.edit_handover_item(
            yacht_id="test-yacht-id",
            user_id="hod-user-id",
            item_id=item_id,
            title="Updated Title",
            summary_text="Updated summary",
        )

        assert result["status"] == "success"

    @pytest.mark.asyncio
    async def test_captain_can_edit_handover_item(self, handlers, mock_db):
        """Captain can edit handover items."""
        item_id = str(uuid.uuid4())
        mock_db.execute.return_value = MagicMock(data=[{
            "id": item_id,
            "title": "Captain Edit",
        }])

        result = await handlers.edit_handover_item(
            yacht_id="test-yacht-id",
            user_id="captain-user-id",
            item_id=item_id,
            title="Captain Edit",
        )

        assert result["status"] == "success"


class TestFinalizeHandover:
    """Tests for finalize_handover action."""

    @pytest.mark.asyncio
    async def test_hod_can_finalize_handover(self, handlers, mock_db):
        """HOD can finalize handover."""
        handover_id = str(uuid.uuid4())
        mock_db.execute.return_value = MagicMock(data=[{
            "id": handover_id,
            "status": "finalized",
        }])

        result = await handlers.finalize_handover(
            yacht_id="test-yacht-id",
            user_id="hod-user-id",
            handover_id=handover_id,
            signature={
                "signed_by": "hod-user-id",
                "signed_at": datetime.now(timezone.utc).isoformat(),
            },
        )

        assert result["status"] == "success"

    @pytest.mark.asyncio
    async def test_captain_can_finalize_handover(self, handlers, mock_db):
        """Captain can finalize handover."""
        handover_id = str(uuid.uuid4())
        mock_db.execute.return_value = MagicMock(data=[{
            "id": handover_id,
            "status": "finalized",
        }])

        result = await handlers.finalize_handover(
            yacht_id="test-yacht-id",
            user_id="captain-user-id",
            handover_id=handover_id,
            signature={
                "signed_by": "captain-user-id",
                "signed_at": datetime.now(timezone.utc).isoformat(),
            },
        )

        assert result["status"] == "success"


class TestExportHandover:
    """Tests for export_handover action."""

    @pytest.mark.asyncio
    async def test_crew_can_export_handover(self, handlers, mock_db):
        """Crew can export handover (read-only)."""
        handover_id = str(uuid.uuid4())
        mock_db.execute.return_value = MagicMock(data=[{
            "id": handover_id,
            "items": [],
        }])

        result = await handlers.export_handover(
            yacht_id="test-yacht-id",
            user_id="crew-user-id",
            handover_id=handover_id,
            format="pdf",
        )

        assert result["status"] == "success"

    @pytest.mark.asyncio
    async def test_hod_can_export_handover(self, handlers, mock_db):
        """HOD can export handover."""
        handover_id = str(uuid.uuid4())
        mock_db.execute.return_value = MagicMock(data=[{
            "id": handover_id,
            "items": [],
        }])

        result = await handlers.export_handover(
            yacht_id="test-yacht-id",
            user_id="hod-user-id",
            handover_id=handover_id,
            format="pdf",
        )

        assert result["status"] == "success"


class TestSignHandover:
    """Tests for sign_outgoing and sign_incoming actions."""

    @pytest.mark.asyncio
    async def test_hod_can_sign_outgoing(self, handlers, mock_db):
        """HOD can sign as outgoing officer."""
        handover_id = str(uuid.uuid4())
        mock_db.execute.return_value = MagicMock(data=[{
            "id": handover_id,
            "outgoing_signature": {"signed_by": "hod-user-id"},
        }])

        result = await handlers.sign_outgoing(
            yacht_id="test-yacht-id",
            user_id="hod-user-id",
            handover_id=handover_id,
            signature={
                "signed_by": "hod-user-id",
                "signed_at": datetime.now(timezone.utc).isoformat(),
            },
        )

        assert result["status"] == "success"

    @pytest.mark.asyncio
    async def test_hod_can_sign_incoming(self, handlers, mock_db):
        """HOD can sign as incoming officer."""
        handover_id = str(uuid.uuid4())
        mock_db.execute.return_value = MagicMock(data=[{
            "id": handover_id,
            "incoming_signature": {"signed_by": "hod-user-id"},
        }])

        result = await handlers.sign_incoming(
            yacht_id="test-yacht-id",
            user_id="hod-user-id",
            handover_id=handover_id,
            signature={
                "signed_by": "hod-user-id",
                "signed_at": datetime.now(timezone.utc).isoformat(),
            },
        )

        assert result["status"] == "success"


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
```
  </action>
  <verify>
File exists: `ls -la apps/api/test_handover_roles.py`
Test count: `grep -c "async def test_" apps/api/test_handover_roles.py`
  </verify>
  <done>test_handover_roles.py exists with role permission tests for all handover actions.</done>
</task>

</tasks>

<verification>
1. E2E test file exists for signature flow
2. Backend role test file exists
3. Both files have multiple test cases
</verification>

<success_criteria>
- HAND-03: Handover role tests verify crew, HOD, and captain permissions
- Signature display tests confirm signature data renders in UI
- E2E tests cover full handover sign-off workflow
</success_criteria>

<output>
After completion, create `.planning/phases/13-gap-remediation-fix-all-failing-requirements-from-verification/13-08-SUMMARY.md`
</output>
