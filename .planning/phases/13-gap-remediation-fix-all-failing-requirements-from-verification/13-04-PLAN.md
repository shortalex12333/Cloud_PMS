---
phase: 13-gap-remediation
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/handlers/email_handlers.py
  - apps/api/handlers/__init__.py
autonomous: true
requirements:
  - EMAIL-01

must_haves:
  truths:
    - "email_handlers.py file exists with handler class"
    - "Handler is registered in the handler registry"
    - "All 5 email actions are implemented and callable"
    - "Handler follows existing handler patterns"
  artifacts:
    - path: "apps/api/handlers/email_handlers.py"
      provides: "Email lens handler with 5 actions"
      min_lines: 200
      exports: ["EmailHandlers", "get_email_handlers"]
  key_links:
    - from: "apps/api/handlers/__init__.py"
      to: "email_handlers"
      via: "import and registration"
      pattern: "email_handlers|get_email_handlers"
---

<objective>
Create email_handlers.py with the 5 required email actions for the email lens.

Purpose: Complete EMAIL-01 verification gap - email handlers file is missing from registry.
Output: New email_handlers.py following warranty_handlers.py pattern.
</objective>

<execution_context>
@/Users/celeste7/.claude/get-shit-done/workflows/execute-plan.md
@/Users/celeste7/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@apps/api/handlers/warranty_handlers.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create email_handlers.py</name>
  <files>apps/api/handlers/email_handlers.py</files>
  <action>
Create email_handlers.py following the warranty_handlers.py pattern:

1. Create file at `apps/api/handlers/email_handlers.py`

2. Implement EmailHandlers class with these 5 actions (per ROADMAP Phase 11):
   - search_emails: Search emails by query, filter by folder
   - view_email_thread: Get full email thread by thread_id
   - extract_entities: Extract equipment/work order/part entities from email
   - link_to_work_order: Link email thread to a work order
   - link_to_equipment: Link email thread to equipment

3. Follow the exact pattern from warranty_handlers.py:
   - Class constructor takes supabase_client
   - Each method is async
   - Each method returns Dict with status, action, result, message
   - Use ResponseBuilder pattern if available
   - Include audit logging via _create_audit_log helper
   - Handle errors with try/except and proper error codes

4. Database tables to query (from migration 00000000000021):
   - email_messages: id, thread_id, subject, body_preview, from_address, received_at
   - email_threads: id, subject, message_count, last_activity_at
   - email_object_links: thread_id, object_type, object_id, confidence, linked_by

5. Implementation skeleton:
```python
"""
Email Handlers
==============

Email lens actions for searching, viewing, and linking emails.

Actions:
- search_emails: Search emails by query
- view_email_thread: View full email thread
- extract_entities: Extract entities from email content
- link_to_work_order: Link thread to work order
- link_to_equipment: Link thread to equipment
"""

from datetime import datetime, timezone
from typing import Dict, Optional, List
import logging

logger = logging.getLogger(__name__)


class EmailHandlers:
    def __init__(self, supabase_client):
        self.db = supabase_client

    async def search_emails(
        self,
        yacht_id: str,
        user_id: str,
        query: str,
        folder: str = "inbox",
        limit: int = 20,
        offset: int = 0,
    ) -> Dict:
        """Search emails by query string."""
        # Implementation...

    async def view_email_thread(
        self,
        yacht_id: str,
        user_id: str,
        thread_id: str,
    ) -> Dict:
        """Get full email thread with all messages."""
        # Implementation...

    async def extract_entities(
        self,
        yacht_id: str,
        user_id: str,
        thread_id: str,
    ) -> Dict:
        """Extract equipment/work order/part entities from email."""
        # Implementation...

    async def link_to_work_order(
        self,
        yacht_id: str,
        user_id: str,
        thread_id: str,
        work_order_id: str,
        confidence: str = "user_confirmed",
    ) -> Dict:
        """Link email thread to work order."""
        # Implementation...

    async def link_to_equipment(
        self,
        yacht_id: str,
        user_id: str,
        thread_id: str,
        equipment_id: str,
        confidence: str = "user_confirmed",
    ) -> Dict:
        """Link email thread to equipment."""
        # Implementation...


def get_email_handlers(supabase_client) -> Dict[str, callable]:
    """Get email handler functions for registration."""
    handlers = EmailHandlers(supabase_client)
    return {
        "search_emails": handlers.search_emails,
        "view_email_thread": handlers.view_email_thread,
        "extract_entities": handlers.extract_entities,
        "link_to_work_order": handlers.link_to_work_order,
        "link_to_equipment": handlers.link_to_equipment,
    }


__all__ = ["EmailHandlers", "get_email_handlers"]
```

6. Each action should:
   - Validate required parameters
   - Query/mutate appropriate database tables
   - Create audit log entry
   - Return standardized response format
  </action>
  <verify>
Python syntax check: `cd /Volumes/Backup/CELESTE/BACK_BUTTON_CLOUD_PMS/apps/api && python -m py_compile handlers/email_handlers.py`
File exists: `ls -la apps/api/handlers/email_handlers.py`
Export check: `grep "get_email_handlers" apps/api/handlers/email_handlers.py`
  </verify>
  <done>email_handlers.py exists with 5 actions, get_email_handlers export, compiles without errors.</done>
</task>

<task type="auto">
  <name>Task 2: Register email handlers in __init__.py</name>
  <files>apps/api/handlers/__init__.py</files>
  <action>
Update handlers/__init__.py to import and register email_handlers:

1. Read current __init__.py to understand registration pattern

2. Add import:
```python
from .email_handlers import get_email_handlers, EmailHandlers
```

3. Add to __all__ list if present:
```python
__all__ = [
    # ... existing exports
    "get_email_handlers",
    "EmailHandlers",
]
```

4. If there's a handler registry dict, add email handlers:
```python
HANDLER_REGISTRY = {
    # ... existing handlers
    **get_email_handlers(supabase_client),
}
```

5. Follow the exact pattern used for other handlers (warranty, handover, etc.)
  </action>
  <verify>
Python syntax check: `cd /Volumes/Backup/CELESTE/BACK_BUTTON_CLOUD_PMS/apps/api && python -m py_compile handlers/__init__.py`
Import check: `grep "email_handlers" apps/api/handlers/__init__.py`
  </verify>
  <done>handlers/__init__.py imports and registers email_handlers, compiles without errors.</done>
</task>

</tasks>

<verification>
1. email_handlers.py file exists in apps/api/handlers/
2. Python compilation passes for both files
3. get_email_handlers is exported and registered
4. All 5 email actions are defined
</verification>

<success_criteria>
- EMAIL-01: email_handlers.py exists and is registered in handler registry
- All 5 email actions (search_emails, view_email_thread, extract_entities, link_to_work_order, link_to_equipment) are implemented
- Handler follows existing codebase patterns
- Python compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/13-gap-remediation-fix-all-failing-requirements-from-verification/13-04-SUMMARY.md`
</output>
