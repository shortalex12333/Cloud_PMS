---
phase: 14
plan: 06
title: Embedding Worker Integration
wave: 3
depends_on: [14-05]
autonomous: true
files_modified:
  - apps/api/workers/embedding_worker_1536.py
---

<objective>
Integrate handover export indexing into the embedding worker so signed handovers become searchable.
</objective>

<context>
After user submits signed handover and HOD countersigns:
1. Extract text from signed HTML
2. Insert into search_index_queue table
3. Embedding worker picks up and processes
4. Creates vector embeddings for semantic search
</context>

## Tasks

### Task 1: Add handover export handler to embedding worker

Update `apps/api/workers/embedding_worker_1536.py` to handle handover_export entity type:

```python
# Add to ENTITY_HANDLERS dict
ENTITY_HANDLERS = {
    # ... existing handlers ...
    "handover_export": handle_handover_export,
}


async def handle_handover_export(entity_id: str, supabase) -> dict:
    """
    Process a handover export for search indexing.

    Extracts text from the signed HTML and creates searchable content.
    """
    # Fetch export record
    result = supabase.table("handover_exports").select(
        "id, handover_id, yacht_id, signed_storage_url, edited_content, user_signature, hod_signature, review_status"
    ).eq("id", entity_id).single().execute()

    if not result.data:
        raise ValueError(f"Handover export {entity_id} not found")

    export_data = result.data

    # Only index complete exports
    if export_data["review_status"] != "complete":
        return {"skipped": True, "reason": "Not complete"}

    # Extract searchable text
    text_parts = []

    # Add section content
    sections = export_data.get("edited_content", {}).get("sections", [])
    for section in sections:
        text_parts.append(f"## {section['title']}")
        text_parts.append(section.get("content", ""))

        for item in section.get("items", []):
            priority = item.get("priority", "")
            content = item.get("content", "")
            text_parts.append(f"[{priority}] {content}")

    # Add signature info
    if export_data.get("user_signature"):
        user_sig = export_data["user_signature"]
        text_parts.append(f"Signed by: {user_sig.get('signer_name')} on {user_sig.get('signed_at')}")

    if export_data.get("hod_signature"):
        hod_sig = export_data["hod_signature"]
        text_parts.append(f"Approved by: {hod_sig.get('signer_name')} on {hod_sig.get('signed_at')}")

    full_text = "\n".join(text_parts)

    # Generate embedding
    embedding = await generate_embedding(full_text)

    # Insert into search index
    supabase.table("search_index").upsert({
        "entity_type": "handover_export",
        "entity_id": entity_id,
        "yacht_id": export_data["yacht_id"],
        "content": full_text[:10000],  # Limit stored text
        "embedding": embedding,
        "metadata": {
            "handover_id": export_data["handover_id"],
            "section_count": len(sections),
            "signed_at": export_data.get("user_signature", {}).get("signed_at"),
            "approved_at": export_data.get("hod_signature", {}).get("signed_at")
        },
        "indexed_at": datetime.utcnow().isoformat()
    }, on_conflict=["entity_type", "entity_id"]).execute()

    return {
        "indexed": True,
        "text_length": len(full_text),
        "section_count": len(sections)
    }
```

### Task 2: Add queue processing for handover exports

Ensure the worker processes from search_index_queue:

```python
async def process_queue():
    """Main worker loop - process items from search_index_queue."""
    supabase = get_supabase_client()

    while True:
        # Fetch pending items (including handover_export)
        result = supabase.table("search_index_queue").select(
            "id, entity_type, entity_id, yacht_id"
        ).eq("status", "pending").order("priority", desc=True).limit(10).execute()

        for item in result.data or []:
            try:
                # Mark as processing
                supabase.table("search_index_queue").update({
                    "status": "processing",
                    "started_at": datetime.utcnow().isoformat()
                }).eq("id", item["id"]).execute()

                # Process based on entity type
                handler = ENTITY_HANDLERS.get(item["entity_type"])
                if handler:
                    result = await handler(item["entity_id"], supabase)

                    # Mark as complete
                    supabase.table("search_index_queue").update({
                        "status": "complete",
                        "completed_at": datetime.utcnow().isoformat(),
                        "result": result
                    }).eq("id", item["id"]).execute()
                else:
                    # Unknown entity type
                    supabase.table("search_index_queue").update({
                        "status": "failed",
                        "error": f"Unknown entity type: {item['entity_type']}"
                    }).eq("id", item["id"]).execute()

            except Exception as e:
                # Mark as failed
                supabase.table("search_index_queue").update({
                    "status": "failed",
                    "error": str(e)
                }).eq("id", item["id"]).execute()

        # Sleep between batches
        await asyncio.sleep(5)
```

### Task 3: Create search_index_queue table migration (if not exists)

```sql
-- Migration: Create search_index_queue if not exists

CREATE TABLE IF NOT EXISTS search_index_queue (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    entity_type TEXT NOT NULL,
    entity_id UUID NOT NULL,
    yacht_id UUID REFERENCES yachts(id),
    priority INTEGER DEFAULT 0,
    status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'processing', 'complete', 'failed')),
    started_at TIMESTAMPTZ,
    completed_at TIMESTAMPTZ,
    result JSONB,
    error TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),

    UNIQUE (entity_type, entity_id)
);

CREATE INDEX IF NOT EXISTS idx_search_index_queue_status
  ON search_index_queue(status, priority DESC)
  WHERE status = 'pending';
```

## Verification

- [ ] handle_handover_export function added to embedding worker
- [ ] Extracts text from edited_content sections
- [ ] Includes signature metadata in indexed content
- [ ] Upserts into search_index table
- [ ] Queue processing handles handover_export entity type
- [ ] Signed handovers appear in search results
