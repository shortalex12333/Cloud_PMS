---
phase: 14
plan: 04
title: HandoverExportLens Component
wave: 2
depends_on: [14-02, 14-03]
autonomous: true
files_modified:
  - apps/web/src/components/lens/HandoverExportLens.tsx
  - apps/web/src/components/lens/handover-export-sections/EditableSectionRenderer.tsx
  - apps/web/src/components/lens/handover-export-sections/SignatureCanvas.tsx
  - apps/web/src/components/lens/handover-export-sections/SignatureSection.tsx
  - apps/web/src/components/lens/handover-export-sections/FinishButton.tsx
  - apps/web/src/components/lens/handover-export-sections/index.ts
  - apps/web/src/app/handover-export/[id]/page.tsx
---

<objective>
Create HandoverExportLens component with two modes: edit (user) and review (HOD). User can fully edit document and sign; HOD sees read-only content and can only countersign.
</objective>

<context>
Pattern: Similar to DocumentLens but with:
- Mode-aware rendering (edit vs review)
- Dual signature section (user + HOD)
- Canvas-based signature capture
- Submit workflow with validation
- Editable sections (add/remove/reorder)
</context>

## Tasks

### Task 1: Create SignatureCanvas component

Create `apps/web/src/components/lens/handover-export-sections/SignatureCanvas.tsx`:

```typescript
'use client';

import { useRef, useState, useEffect } from 'react';

interface SignatureCanvasProps {
  onSignatureChange: (base64: string | null) => void;
  initialSignature?: string;
  disabled?: boolean;
  label: string;
}

export function SignatureCanvas({
  onSignatureChange,
  initialSignature,
  disabled = false,
  label
}: SignatureCanvasProps) {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [isDrawing, setIsDrawing] = useState(false);
  const [hasSignature, setHasSignature] = useState(!!initialSignature);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    // Set up canvas
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 2;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    // Draw initial signature if provided
    if (initialSignature) {
      const img = new Image();
      img.onload = () => {
        ctx.drawImage(img, 0, 0);
      };
      img.src = initialSignature;
    }
  }, [initialSignature]);

  const getCoordinates = (e: React.MouseEvent | React.TouchEvent) => {
    const canvas = canvasRef.current;
    if (!canvas) return { x: 0, y: 0 };

    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;

    if ('touches' in e) {
      return {
        x: (e.touches[0].clientX - rect.left) * scaleX,
        y: (e.touches[0].clientY - rect.top) * scaleY
      };
    }
    return {
      x: (e.clientX - rect.left) * scaleX,
      y: (e.clientY - rect.top) * scaleY
    };
  };

  const startDrawing = (e: React.MouseEvent | React.TouchEvent) => {
    if (disabled) return;
    const canvas = canvasRef.current;
    const ctx = canvas?.getContext('2d');
    if (!ctx) return;

    setIsDrawing(true);
    const { x, y } = getCoordinates(e);
    ctx.beginPath();
    ctx.moveTo(x, y);
  };

  const draw = (e: React.MouseEvent | React.TouchEvent) => {
    if (!isDrawing || disabled) return;
    const canvas = canvasRef.current;
    const ctx = canvas?.getContext('2d');
    if (!ctx) return;

    const { x, y } = getCoordinates(e);
    ctx.lineTo(x, y);
    ctx.stroke();
  };

  const stopDrawing = () => {
    if (!isDrawing) return;
    setIsDrawing(false);
    setHasSignature(true);

    const canvas = canvasRef.current;
    if (canvas) {
      const base64 = canvas.toDataURL('image/png');
      onSignatureChange(base64);
    }
  };

  const clearSignature = () => {
    const canvas = canvasRef.current;
    const ctx = canvas?.getContext('2d');
    if (!ctx || !canvas) return;

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    setHasSignature(false);
    onSignatureChange(null);
  };

  return (
    <div className="flex flex-col gap-2">
      <label className="text-sm font-medium text-txt-secondary">{label}</label>
      <div className="relative border border-surface-border rounded-lg bg-surface-primary">
        <canvas
          ref={canvasRef}
          width={400}
          height={150}
          className={`w-full h-[150px] touch-none ${disabled ? 'cursor-not-allowed opacity-50' : 'cursor-crosshair'}`}
          onMouseDown={startDrawing}
          onMouseMove={draw}
          onMouseUp={stopDrawing}
          onMouseLeave={stopDrawing}
          onTouchStart={startDrawing}
          onTouchMove={draw}
          onTouchEnd={stopDrawing}
        />
        {!hasSignature && !disabled && (
          <div className="absolute inset-0 flex items-center justify-center pointer-events-none text-txt-tertiary">
            Sign here
          </div>
        )}
      </div>
      {hasSignature && !disabled && (
        <button
          type="button"
          onClick={clearSignature}
          className="self-end text-sm text-brand-interactive hover:underline"
        >
          Clear signature
        </button>
      )}
    </div>
  );
}
```

### Task 2: Create EditableSectionRenderer component

Create `apps/web/src/components/lens/handover-export-sections/EditableSectionRenderer.tsx`:

```typescript
'use client';

import { useState } from 'react';
import { SectionContainer } from '@/components/ui/SectionContainer';
import { GhostButton } from '@/components/ui/GhostButton';

interface SectionItem {
  id: string;
  content: string;
  entity_type?: string;
  entity_id?: string;
  priority?: 'critical' | 'action' | 'fyi';
}

interface Section {
  id: string;
  title: string;
  content: string;
  items: SectionItem[];
  is_critical: boolean;
  order: number;
}

interface EditableSectionRendererProps {
  sections: Section[];
  onSectionsChange: (sections: Section[]) => void;
  mode: 'edit' | 'review';
}

export function EditableSectionRenderer({
  sections,
  onSectionsChange,
  mode
}: EditableSectionRendererProps) {
  const isEditable = mode === 'edit';

  const updateSection = (sectionId: string, updates: Partial<Section>) => {
    if (!isEditable) return;
    onSectionsChange(
      sections.map(s => s.id === sectionId ? { ...s, ...updates } : s)
    );
  };

  const addSection = () => {
    if (!isEditable) return;
    const newSection: Section = {
      id: `section-${Date.now()}`,
      title: 'New Section',
      content: '',
      items: [],
      is_critical: false,
      order: sections.length
    };
    onSectionsChange([...sections, newSection]);
  };

  const removeSection = (sectionId: string) => {
    if (!isEditable) return;
    onSectionsChange(sections.filter(s => s.id !== sectionId));
  };

  const moveSection = (sectionId: string, direction: 'up' | 'down') => {
    if (!isEditable) return;
    const index = sections.findIndex(s => s.id === sectionId);
    if (index === -1) return;
    if (direction === 'up' && index === 0) return;
    if (direction === 'down' && index === sections.length - 1) return;

    const newSections = [...sections];
    const swapIndex = direction === 'up' ? index - 1 : index + 1;
    [newSections[index], newSections[swapIndex]] = [newSections[swapIndex], newSections[index]];

    // Update order values
    newSections.forEach((s, i) => { s.order = i; });
    onSectionsChange(newSections);
  };

  const addItem = (sectionId: string) => {
    if (!isEditable) return;
    const section = sections.find(s => s.id === sectionId);
    if (!section) return;

    const newItem: SectionItem = {
      id: `item-${Date.now()}`,
      content: '',
      priority: 'fyi'
    };

    updateSection(sectionId, {
      items: [...section.items, newItem]
    });
  };

  const updateItem = (sectionId: string, itemId: string, content: string) => {
    if (!isEditable) return;
    const section = sections.find(s => s.id === sectionId);
    if (!section) return;

    updateSection(sectionId, {
      items: section.items.map(i =>
        i.id === itemId ? { ...i, content } : i
      )
    });
  };

  const removeItem = (sectionId: string, itemId: string) => {
    if (!isEditable) return;
    const section = sections.find(s => s.id === sectionId);
    if (!section) return;

    updateSection(sectionId, {
      items: section.items.filter(i => i.id !== itemId)
    });
  };

  const getPriorityBadgeColor = (priority?: string) => {
    switch (priority) {
      case 'critical': return 'bg-status-critical/20 text-status-critical';
      case 'action': return 'bg-status-warning/20 text-status-warning';
      case 'fyi': return 'bg-surface-secondary text-txt-secondary';
      default: return 'bg-surface-secondary text-txt-secondary';
    }
  };

  return (
    <div className="flex flex-col gap-4">
      {sections
        .sort((a, b) => a.order - b.order)
        .map((section) => (
          <SectionContainer
            key={section.id}
            title={
              isEditable ? (
                <input
                  type="text"
                  value={section.title}
                  onChange={(e) => updateSection(section.id, { title: e.target.value })}
                  className="bg-transparent border-b border-transparent hover:border-surface-border focus:border-brand-interactive outline-none w-full"
                />
              ) : (
                section.title
              )
            }
            badge={section.is_critical ? 'CRITICAL' : undefined}
            badgeColor={section.is_critical ? 'critical' : undefined}
            stickyTop={56}
          >
            {/* Section controls (edit mode only) */}
            {isEditable && (
              <div className="flex gap-2 mb-3">
                <GhostButton size="sm" onClick={() => moveSection(section.id, 'up')}>↑</GhostButton>
                <GhostButton size="sm" onClick={() => moveSection(section.id, 'down')}>↓</GhostButton>
                <GhostButton size="sm" onClick={() => removeSection(section.id)}>Remove</GhostButton>
                <label className="flex items-center gap-1 text-sm">
                  <input
                    type="checkbox"
                    checked={section.is_critical}
                    onChange={(e) => updateSection(section.id, { is_critical: e.target.checked })}
                  />
                  Critical
                </label>
              </div>
            )}

            {/* Section content */}
            {isEditable ? (
              <textarea
                value={section.content}
                onChange={(e) => updateSection(section.id, { content: e.target.value })}
                className="w-full min-h-[80px] p-2 bg-surface-secondary rounded border border-surface-border resize-y"
                placeholder="Section content..."
              />
            ) : (
              <p className="text-txt-primary whitespace-pre-wrap">{section.content}</p>
            )}

            {/* Section items */}
            <div className="mt-4 flex flex-col gap-2">
              {section.items.map((item) => (
                <div key={item.id} className="flex items-start gap-2 p-2 bg-surface-secondary rounded">
                  <span className={`px-2 py-0.5 text-xs rounded ${getPriorityBadgeColor(item.priority)}`}>
                    {item.priority || 'fyi'}
                  </span>
                  {isEditable ? (
                    <>
                      <input
                        type="text"
                        value={item.content}
                        onChange={(e) => updateItem(section.id, item.id, e.target.value)}
                        className="flex-1 bg-transparent border-b border-transparent hover:border-surface-border focus:border-brand-interactive outline-none"
                        placeholder="Item content..."
                      />
                      <button
                        onClick={() => removeItem(section.id, item.id)}
                        className="text-txt-tertiary hover:text-status-critical"
                      >
                        ×
                      </button>
                    </>
                  ) : (
                    <span className="flex-1 text-txt-primary">{item.content}</span>
                  )}
                </div>
              ))}

              {isEditable && (
                <button
                  onClick={() => addItem(section.id)}
                  className="self-start text-sm text-brand-interactive hover:underline"
                >
                  + Add item
                </button>
              )}
            </div>
          </SectionContainer>
        ))}

      {/* Add section button (edit mode only) */}
      {isEditable && (
        <button
          onClick={addSection}
          className="p-4 border-2 border-dashed border-surface-border rounded-lg text-txt-secondary hover:border-brand-interactive hover:text-brand-interactive transition-colors"
        >
          + Add Section
        </button>
      )}
    </div>
  );
}
```

### Task 3: Create SignatureSection component

Create `apps/web/src/components/lens/handover-export-sections/SignatureSection.tsx`:

```typescript
'use client';

import { SignatureCanvas } from './SignatureCanvas';

interface SignatureData {
  image_base64: string | null;
  signed_at: string | null;
  signer_name: string | null;
  signer_id: string | null;
}

interface SignatureSectionProps {
  mode: 'edit' | 'review';
  userSignature: SignatureData | null;
  hodSignature: SignatureData | null;
  onUserSignatureChange: (base64: string | null) => void;
  onHodSignatureChange: (base64: string | null) => void;
  currentUserName: string;
  currentUserId: string;
}

export function SignatureSection({
  mode,
  userSignature,
  hodSignature,
  onUserSignatureChange,
  onHodSignatureChange,
  currentUserName,
  currentUserId
}: SignatureSectionProps) {
  const isEditMode = mode === 'edit';
  const isReviewMode = mode === 'review';

  return (
    <div className="border-t border-surface-border pt-6 mt-6">
      <h3 className="text-lg font-semibold text-txt-primary mb-4">Signatures</h3>

      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        {/* User Signature */}
        <div className="flex flex-col gap-2">
          <div className="text-sm font-medium text-txt-secondary">Prepared By</div>
          {userSignature?.image_base64 ? (
            <div className="border border-surface-border rounded-lg p-4 bg-surface-secondary">
              <img
                src={userSignature.image_base64}
                alt="User signature"
                className="h-[100px] object-contain"
              />
              <div className="mt-2 text-sm text-txt-secondary">
                {userSignature.signer_name} — {userSignature.signed_at}
              </div>
            </div>
          ) : isEditMode ? (
            <SignatureCanvas
              label="Your Signature"
              onSignatureChange={onUserSignatureChange}
              disabled={false}
            />
          ) : (
            <div className="border border-surface-border rounded-lg p-4 bg-surface-secondary text-txt-tertiary">
              Not yet signed
            </div>
          )}
        </div>

        {/* HOD Countersignature */}
        <div className="flex flex-col gap-2">
          <div className="text-sm font-medium text-txt-secondary">Approved By (HOD)</div>
          {hodSignature?.image_base64 ? (
            <div className="border border-surface-border rounded-lg p-4 bg-surface-secondary">
              <img
                src={hodSignature.image_base64}
                alt="HOD signature"
                className="h-[100px] object-contain"
              />
              <div className="mt-2 text-sm text-txt-secondary">
                {hodSignature.signer_name} — {hodSignature.signed_at}
              </div>
            </div>
          ) : isReviewMode ? (
            <SignatureCanvas
              label="HOD Countersignature"
              onSignatureChange={onHodSignatureChange}
              disabled={!userSignature?.image_base64}
            />
          ) : (
            <div className="border border-surface-border rounded-lg p-4 bg-surface-secondary text-txt-tertiary">
              {userSignature?.image_base64
                ? 'Awaiting HOD countersignature'
                : 'User must sign first'}
            </div>
          )}
        </div>
      </div>

      {/* Status message */}
      {isEditMode && !userSignature?.image_base64 && (
        <p className="mt-4 text-sm text-status-warning" id="signature-required-message">
          You must sign the handover before submitting
        </p>
      )}
      {isReviewMode && userSignature?.image_base64 && !hodSignature?.image_base64 && (
        <p className="mt-4 text-sm text-brand-interactive">
          Please review the document and add your countersignature to approve
        </p>
      )}
    </div>
  );
}
```

### Task 4: Create FinishButton component

Create `apps/web/src/components/lens/handover-export-sections/FinishButton.tsx`:

```typescript
'use client';

import { PrimaryButton } from '@/components/ui/PrimaryButton';
import { toast } from 'sonner';

interface FinishButtonProps {
  mode: 'edit' | 'review';
  hasUserSignature: boolean;
  hasHodSignature: boolean;
  onSubmit: () => Promise<void>;
  onCountersign: () => Promise<void>;
  isLoading: boolean;
}

export function FinishButton({
  mode,
  hasUserSignature,
  hasHodSignature,
  onSubmit,
  onCountersign,
  isLoading
}: FinishButtonProps) {
  const isEditMode = mode === 'edit';
  const isReviewMode = mode === 'review';

  const handleClick = async () => {
    if (isEditMode) {
      if (!hasUserSignature) {
        toast.error('You must sign the handover before submitting');
        // Scroll to signature section
        document.getElementById('signature-required-message')?.scrollIntoView({
          behavior: 'smooth',
          block: 'center'
        });
        return;
      }
      await onSubmit();
    } else if (isReviewMode) {
      if (!hasHodSignature) {
        toast.error('You must countersign before approving');
        return;
      }
      await onCountersign();
    }
  };

  const buttonLabel = isEditMode
    ? 'Finish and Submit'
    : 'Approve and Countersign';

  const isDisabled = isEditMode
    ? !hasUserSignature
    : !hasHodSignature;

  return (
    <PrimaryButton
      onClick={handleClick}
      disabled={isDisabled || isLoading}
      className={isDisabled ? 'opacity-50 cursor-not-allowed' : ''}
    >
      {isLoading ? 'Processing...' : buttonLabel}
    </PrimaryButton>
  );
}
```

### Task 5: Create index.ts barrel export

Create `apps/web/src/components/lens/handover-export-sections/index.ts`:

```typescript
export { SignatureCanvas } from './SignatureCanvas';
export { EditableSectionRenderer } from './EditableSectionRenderer';
export { SignatureSection } from './SignatureSection';
export { FinishButton } from './FinishButton';
```

### Task 6: Create HandoverExportLens component

Create `apps/web/src/components/lens/HandoverExportLens.tsx`:

```typescript
'use client';

import { useState, useCallback } from 'react';
import { LensContainer } from '@/components/ui/LensContainer';
import { LensHeader, LensTitleBlock } from '@/components/ui/LensHeader';
import { VitalSignsRow, VitalSign } from '@/components/ui/VitalSignsRow';
import { StatusPill } from '@/components/ui/StatusPill';
import {
  EditableSectionRenderer,
  SignatureSection,
  FinishButton
} from './handover-export-sections';
import { toast } from 'sonner';

interface Section {
  id: string;
  title: string;
  content: string;
  items: Array<{
    id: string;
    content: string;
    entity_type?: string;
    entity_id?: string;
    priority?: 'critical' | 'action' | 'fyi';
  }>;
  is_critical: boolean;
  order: number;
}

interface SignatureData {
  image_base64: string | null;
  signed_at: string | null;
  signer_name: string | null;
  signer_id: string | null;
}

interface HandoverExportLensProps {
  exportId: string;
  mode: 'edit' | 'review';
  title: string;
  generatedAt: string;
  yachtName: string;
  preparedBy: string;
  reviewStatus: 'pending_review' | 'pending_hod_signature' | 'complete';
  initialSections: Section[];
  userSignature: SignatureData | null;
  hodSignature: SignatureData | null;
  currentUser: {
    id: string;
    name: string;
    role: string;
  };
  onClose: () => void;
  onSubmit: (data: {
    sections: Section[];
    userSignature: SignatureData;
  }) => Promise<void>;
  onCountersign: (hodSignature: SignatureData) => Promise<void>;
  onSaveDraft?: (sections: Section[]) => Promise<void>;
}

export function HandoverExportLens({
  exportId,
  mode,
  title,
  generatedAt,
  yachtName,
  preparedBy,
  reviewStatus,
  initialSections,
  userSignature: initialUserSignature,
  hodSignature: initialHodSignature,
  currentUser,
  onClose,
  onSubmit,
  onCountersign,
  onSaveDraft
}: HandoverExportLensProps) {
  const [sections, setSections] = useState<Section[]>(initialSections);
  const [userSignature, setUserSignature] = useState<string | null>(
    initialUserSignature?.image_base64 ?? null
  );
  const [hodSignature, setHodSignature] = useState<string | null>(
    initialHodSignature?.image_base64 ?? null
  );
  const [isLoading, setIsLoading] = useState(false);
  const [isDirty, setIsDirty] = useState(false);

  const handleSectionsChange = useCallback((newSections: Section[]) => {
    setSections(newSections);
    setIsDirty(true);
  }, []);

  const handleUserSignatureChange = useCallback((base64: string | null) => {
    setUserSignature(base64);
    setIsDirty(true);
  }, []);

  const handleHodSignatureChange = useCallback((base64: string | null) => {
    setHodSignature(base64);
  }, []);

  const handleSubmit = async () => {
    if (!userSignature) {
      toast.error('You must sign the handover before submitting');
      return;
    }

    setIsLoading(true);
    try {
      await onSubmit({
        sections,
        userSignature: {
          image_base64: userSignature,
          signed_at: new Date().toISOString(),
          signer_name: currentUser.name,
          signer_id: currentUser.id
        }
      });
      toast.success('Handover submitted for HOD approval');
    } catch (error) {
      toast.error('Failed to submit handover');
      console.error(error);
    } finally {
      setIsLoading(false);
    }
  };

  const handleCountersign = async () => {
    if (!hodSignature) {
      toast.error('You must countersign before approving');
      return;
    }

    setIsLoading(true);
    try {
      await onCountersign({
        image_base64: hodSignature,
        signed_at: new Date().toISOString(),
        signer_name: currentUser.name,
        signer_id: currentUser.id
      });
      toast.success('Handover approved and countersigned');
    } catch (error) {
      toast.error('Failed to countersign handover');
      console.error(error);
    } finally {
      setIsLoading(false);
    }
  };

  // Auto-save draft every 30 seconds if dirty
  // useEffect(() => {
  //   if (!isDirty || mode !== 'edit' || !onSaveDraft) return;
  //   const timer = setTimeout(() => {
  //     onSaveDraft(sections);
  //     setIsDirty(false);
  //   }, 30000);
  //   return () => clearTimeout(timer);
  // }, [isDirty, sections, mode, onSaveDraft]);

  const getStatusColor = (status: string): 'neutral' | 'warning' | 'success' => {
    switch (status) {
      case 'pending_review': return 'neutral';
      case 'pending_hod_signature': return 'warning';
      case 'complete': return 'success';
      default: return 'neutral';
    }
  };

  const getStatusLabel = (status: string): string => {
    switch (status) {
      case 'pending_review': return 'Pending Review';
      case 'pending_hod_signature': return 'Awaiting HOD';
      case 'complete': return 'Complete';
      default: return status;
    }
  };

  const vitalSigns: VitalSign[] = [
    {
      label: 'Status',
      value: <StatusPill status={getStatusColor(reviewStatus)} label={getStatusLabel(reviewStatus)} />
    },
    { label: 'Yacht', value: yachtName },
    { label: 'Prepared By', value: preparedBy },
    { label: 'Generated', value: new Date(generatedAt).toLocaleDateString() },
    { label: 'Sections', value: String(sections.length) }
  ];

  return (
    <LensContainer onClose={onClose}>
      <LensHeader
        entityType="handover_export"
        onBack={onClose}
        onClose={onClose}
        actionSlot={
          <FinishButton
            mode={mode}
            hasUserSignature={!!userSignature}
            hasHodSignature={!!hodSignature}
            onSubmit={handleSubmit}
            onCountersign={handleCountersign}
            isLoading={isLoading}
          />
        }
      >
        <LensTitleBlock
          displayTitle={title}
          subtitle={`Export ID: ${exportId}`}
        />
      </LensHeader>

      <VitalSignsRow signs={vitalSigns} />

      {/* Mode indicator */}
      <div className={`px-4 py-2 text-sm ${mode === 'edit' ? 'bg-brand-surface text-brand-interactive' : 'bg-surface-secondary text-txt-secondary'}`}>
        {mode === 'edit'
          ? 'Edit Mode — You can modify sections and sign'
          : 'Review Mode — Read-only, countersign to approve'}
      </div>

      {/* Editable sections */}
      <div className="p-4">
        <EditableSectionRenderer
          sections={sections}
          onSectionsChange={handleSectionsChange}
          mode={mode}
        />

        {/* Signature section */}
        <SignatureSection
          mode={mode}
          userSignature={userSignature ? {
            image_base64: userSignature,
            signed_at: initialUserSignature?.signed_at ?? null,
            signer_name: initialUserSignature?.signer_name ?? currentUser.name,
            signer_id: initialUserSignature?.signer_id ?? currentUser.id
          } : null}
          hodSignature={hodSignature ? {
            image_base64: hodSignature,
            signed_at: initialHodSignature?.signed_at ?? null,
            signer_name: initialHodSignature?.signer_name ?? null,
            signer_id: initialHodSignature?.signer_id ?? null
          } : null}
          onUserSignatureChange={handleUserSignatureChange}
          onHodSignatureChange={handleHodSignatureChange}
          currentUserName={currentUser.name}
          currentUserId={currentUser.id}
        />
      </div>
    </LensContainer>
  );
}
```

### Task 7: Create route page

Create `apps/web/src/app/handover-export/[id]/page.tsx`:

```typescript
import { createServerClient } from '@/lib/supabase/server';
import { redirect, notFound } from 'next/navigation';
import { HandoverExportLens } from '@/components/lens/HandoverExportLens';

export default async function HandoverExportPage({
  params,
  searchParams
}: {
  params: { id: string };
  searchParams: { mode?: 'edit' | 'review' };
}) {
  const supabase = createServerClient();

  // Get current user
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) redirect('/login');

  // Fetch user profile
  const { data: profile } = await supabase
    .from('auth_users_profiles')
    .select('full_name, role')
    .eq('id', user.id)
    .single();

  // Fetch handover export
  const { data: exportData, error } = await supabase
    .from('handover_exports')
    .select(`
      id,
      handover_id,
      yacht_id,
      original_storage_url,
      signed_storage_url,
      edited_content,
      user_signature,
      user_signed_at,
      hod_signature,
      hod_signed_at,
      review_status,
      created_at,
      yachts (name)
    `)
    .eq('id', params.id)
    .single();

  if (error || !exportData) {
    notFound();
  }

  // Determine mode based on user role and export status
  let mode: 'edit' | 'review' = searchParams.mode || 'edit';

  // If user already signed, force review mode
  if (exportData.user_signature && exportData.review_status !== 'pending_review') {
    mode = 'review';
  }

  // Parse sections from edited_content or fetch from original HTML
  let sections = exportData.edited_content?.sections || [];

  // If no edited content yet, parse from original HTML
  if (!sections.length && exportData.original_storage_url) {
    // TODO: Fetch and parse original HTML via API
    sections = [];
  }

  const currentUser = {
    id: user.id,
    name: profile?.full_name || user.email || 'Unknown',
    role: profile?.role || 'crew'
  };

  // Client component wrapper needed for interactivity
  return (
    <HandoverExportLensClient
      exportId={params.id}
      mode={mode}
      title={`Handover Export`}
      generatedAt={exportData.created_at}
      yachtName={exportData.yachts?.name || 'Unknown Yacht'}
      preparedBy={currentUser.name}
      reviewStatus={exportData.review_status || 'pending_review'}
      initialSections={sections}
      userSignature={exportData.user_signature}
      hodSignature={exportData.hod_signature}
      currentUser={currentUser}
    />
  );
}

// Client wrapper for actions
'use client';

import { useRouter } from 'next/navigation';
import { HandoverExportLens } from '@/components/lens/HandoverExportLens';

function HandoverExportLensClient(props: any) {
  const router = useRouter();

  const handleClose = () => {
    router.back();
  };

  const handleSubmit = async (data: any) => {
    const response = await fetch(`/api/handover-export/${props.exportId}/submit`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data)
    });
    if (!response.ok) throw new Error('Submit failed');
    router.refresh();
  };

  const handleCountersign = async (hodSignature: any) => {
    const response = await fetch(`/api/handover-export/${props.exportId}/countersign`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ hodSignature })
    });
    if (!response.ok) throw new Error('Countersign failed');
    router.refresh();
  };

  return (
    <HandoverExportLens
      {...props}
      onClose={handleClose}
      onSubmit={handleSubmit}
      onCountersign={handleCountersign}
    />
  );
}
```

## Verification

- [ ] HandoverExportLens renders in edit mode with editable sections
- [ ] HandoverExportLens renders in review mode with read-only sections
- [ ] SignatureCanvas captures drawing and exports base64
- [ ] EditableSectionRenderer allows add/remove/reorder sections
- [ ] FinishButton blocks submit until signature present
- [ ] Toast shown when clicking submit without signature
- [ ] /handover-export/[id] route renders correctly
- [ ] TypeScript compiles with no errors
