---
phase: 14
plan: 05
title: Two-Bucket Storage + API Endpoints
wave: 2
depends_on: [14-02, 14-03]
autonomous: true
files_modified:
  - apps/api/routes/handover_export_routes.py
  - apps/web/src/app/api/handover-export/[id]/content/route.ts
  - apps/web/src/app/api/handover-export/[id]/save-draft/route.ts
  - apps/web/src/app/api/handover-export/[id]/submit/route.ts
  - apps/web/src/app/api/handover-export/[id]/countersign/route.ts
---

<objective>
Implement two-bucket storage (original + signed) and API endpoints for content retrieval, draft saving, user submission, and HOD countersigning.
</objective>

<context>
Storage paths:
- `handover-exports/{yacht_id}/original/{export_id}.html` - AI-generated (immutable)
- `handover-exports/{yacht_id}/signed/{export_id}.html` - User-edited + both signatures

API endpoints:
- GET /content - Get parsed editable content
- POST /save-draft - Auto-save user edits (no signature)
- POST /submit - User signs + submits → notify HOD
- POST /countersign - HOD countersigns → complete
</context>

## Tasks

### Task 1: Create Python routes for handover export

Create/update `apps/api/routes/handover_export_routes.py`:

```python
"""
Handover Export Routes - API endpoints for editable handover exports.
"""
from fastapi import APIRouter, HTTPException, Depends
from pydantic import BaseModel
from typing import Optional, List
import json
from datetime import datetime

from ..services.handover_html_parser import parse_handover_html, document_to_dict
from ..services.supabase_client import get_supabase_client
from ..services.auth import get_current_user

router = APIRouter(prefix="/v1/handover/export", tags=["handover-export"])


class SectionItem(BaseModel):
    id: str
    content: str
    entity_type: Optional[str] = None
    entity_id: Optional[str] = None
    priority: Optional[str] = None


class Section(BaseModel):
    id: str
    title: str
    content: str
    items: List[SectionItem]
    is_critical: bool
    order: int


class SignatureData(BaseModel):
    image_base64: str
    signed_at: str
    signer_name: str
    signer_id: str


class SubmitRequest(BaseModel):
    sections: List[Section]
    userSignature: SignatureData


class CountersignRequest(BaseModel):
    hodSignature: SignatureData


@router.get("/{export_id}/content")
async def get_export_content(
    export_id: str,
    user=Depends(get_current_user)
):
    """Get parsed editable content for a handover export."""
    supabase = get_supabase_client()

    # Fetch export record
    result = supabase.table("handover_exports").select(
        "id, handover_id, yacht_id, original_storage_url, edited_content, review_status, created_at"
    ).eq("id", export_id).single().execute()

    if not result.data:
        raise HTTPException(status_code=404, detail="Export not found")

    export_data = result.data

    # If edited content exists, return it
    if export_data.get("edited_content"):
        return {
            "id": export_id,
            "sections": export_data["edited_content"].get("sections", []),
            "review_status": export_data["review_status"],
            "from_cache": True
        }

    # Otherwise, fetch and parse original HTML
    original_url = export_data.get("original_storage_url")
    if not original_url:
        raise HTTPException(status_code=404, detail="Original HTML not available")

    # Download HTML from Supabase Storage
    storage_path = original_url.replace("handover-exports/", "")
    html_bytes = supabase.storage.from_("handover-exports").download(storage_path)
    html_content = html_bytes.decode("utf-8")

    # Parse HTML into editable structure
    document = parse_handover_html(html_content, export_id)

    return {
        "id": export_id,
        "sections": [
            {
                "id": s.id,
                "title": s.title,
                "content": s.content,
                "items": [
                    {
                        "id": i.id,
                        "content": i.content,
                        "entity_type": i.entity_type,
                        "entity_id": i.entity_id,
                        "priority": i.priority
                    }
                    for i in s.items
                ],
                "is_critical": s.is_critical,
                "order": s.order
            }
            for s in document.sections
        ],
        "review_status": export_data["review_status"],
        "from_cache": False
    }


@router.post("/{export_id}/save-draft")
async def save_draft(
    export_id: str,
    sections: List[Section],
    user=Depends(get_current_user)
):
    """Auto-save user edits without signature."""
    supabase = get_supabase_client()

    # Verify export exists and user has access
    result = supabase.table("handover_exports").select(
        "id, yacht_id, review_status"
    ).eq("id", export_id).single().execute()

    if not result.data:
        raise HTTPException(status_code=404, detail="Export not found")

    if result.data["review_status"] != "pending_review":
        raise HTTPException(status_code=400, detail="Cannot edit after submission")

    # Update edited content
    supabase.table("handover_exports").update({
        "edited_content": {
            "sections": [s.dict() for s in sections],
            "last_saved_at": datetime.utcnow().isoformat(),
            "saved_by": user.id
        }
    }).eq("id", export_id).execute()

    return {"success": True, "saved_at": datetime.utcnow().isoformat()}


@router.post("/{export_id}/submit")
async def submit_export(
    export_id: str,
    request: SubmitRequest,
    user=Depends(get_current_user)
):
    """User signs and submits handover for HOD approval."""
    supabase = get_supabase_client()

    # Fetch export
    result = supabase.table("handover_exports").select(
        "id, yacht_id, review_status, original_storage_url"
    ).eq("id", export_id).single().execute()

    if not result.data:
        raise HTTPException(status_code=404, detail="Export not found")

    export_data = result.data

    if export_data["review_status"] != "pending_review":
        raise HTTPException(status_code=400, detail="Already submitted")

    yacht_id = export_data["yacht_id"]

    # Generate signed HTML with user's edits
    signed_html = _generate_signed_html(request.sections, request.userSignature)

    # Upload to Bucket 2 (signed)
    signed_path = f"{yacht_id}/signed/{export_id}.html"
    supabase.storage.from_("handover-exports").upload(
        signed_path,
        signed_html.encode("utf-8"),
        {"content-type": "text/html"}
    )

    # Update database record
    supabase.table("handover_exports").update({
        "edited_content": {
            "sections": [s.dict() for s in request.sections]
        },
        "signed_storage_url": f"handover-exports/{signed_path}",
        "user_signature": request.userSignature.dict(),
        "user_signed_at": request.userSignature.signed_at,
        "user_submitted_at": datetime.utcnow().isoformat(),
        "review_status": "pending_hod_signature"
    }).eq("id", export_id).execute()

    # Create ledger notification for HOD
    _notify_hod_for_countersign(supabase, export_id, yacht_id, user)

    return {
        "success": True,
        "review_status": "pending_hod_signature",
        "signed_storage_url": f"handover-exports/{signed_path}"
    }


@router.post("/{export_id}/countersign")
async def countersign_export(
    export_id: str,
    request: CountersignRequest,
    user=Depends(get_current_user)
):
    """HOD countersigns the handover to complete."""
    supabase = get_supabase_client()

    # Verify user is HOD
    profile = supabase.table("auth_users_profiles").select(
        "role"
    ).eq("id", user.id).single().execute()

    if profile.data["role"] not in ["hod", "captain", "manager"]:
        raise HTTPException(status_code=403, detail="Only HOD+ can countersign")

    # Fetch export
    result = supabase.table("handover_exports").select(
        "id, yacht_id, review_status, signed_storage_url, edited_content, user_signature"
    ).eq("id", export_id).single().execute()

    if not result.data:
        raise HTTPException(status_code=404, detail="Export not found")

    export_data = result.data

    if export_data["review_status"] != "pending_hod_signature":
        raise HTTPException(status_code=400, detail="Not awaiting countersign")

    yacht_id = export_data["yacht_id"]

    # Update signed HTML with HOD signature
    # (Re-upload with both signatures)
    signed_html = _generate_final_html(
        export_data["edited_content"]["sections"],
        export_data["user_signature"],
        request.hodSignature.dict()
    )

    signed_path = f"{yacht_id}/signed/{export_id}.html"
    supabase.storage.from_("handover-exports").update(
        signed_path,
        signed_html.encode("utf-8"),
        {"content-type": "text/html"}
    )

    # Update database record
    supabase.table("handover_exports").update({
        "hod_signature": request.hodSignature.dict(),
        "hod_signed_at": request.hodSignature.signed_at,
        "review_status": "complete"
    }).eq("id", export_id).execute()

    # Trigger embedding worker for indexing
    _trigger_indexing(export_id, yacht_id)

    return {
        "success": True,
        "review_status": "complete"
    }


def _generate_signed_html(sections: List[Section], user_sig: SignatureData) -> str:
    """Generate HTML document with user's edits and signature."""
    html_parts = [
        "<!DOCTYPE html>",
        "<html><head><title>Handover Export</title></head>",
        "<body>"
    ]

    for section in sorted(sections, key=lambda s: s.order):
        html_parts.append(f'<section class="handover-section{"" if not section.is_critical else " critical"}">')
        html_parts.append(f"<h2>{section.title}</h2>")
        html_parts.append(f"<p>{section.content}</p>")

        if section.items:
            html_parts.append("<ul>")
            for item in section.items:
                html_parts.append(f'<li class="{item.priority or "fyi"}">{item.content}</li>')
            html_parts.append("</ul>")

        html_parts.append("</section>")

    # User signature
    html_parts.append('<div class="signatures">')
    html_parts.append('<div class="signature-block" data-role="outgoing">')
    html_parts.append(f'<img src="{user_sig.image_base64}" alt="User signature"/>')
    html_parts.append(f'<p>{user_sig.signer_name} — {user_sig.signed_at}</p>')
    html_parts.append('</div>')
    html_parts.append('<div class="signature-block" data-role="hod">')
    html_parts.append('<p>Awaiting HOD countersignature</p>')
    html_parts.append('</div>')
    html_parts.append('</div>')

    html_parts.append("</body></html>")
    return "\n".join(html_parts)


def _generate_final_html(sections: list, user_sig: dict, hod_sig: dict) -> str:
    """Generate final HTML with both signatures."""
    html_parts = [
        "<!DOCTYPE html>",
        "<html><head><title>Handover Export - Complete</title></head>",
        "<body>"
    ]

    for section in sorted(sections, key=lambda s: s["order"]):
        html_parts.append(f'<section class="handover-section{"" if not section["is_critical"] else " critical"}">')
        html_parts.append(f"<h2>{section['title']}</h2>")
        html_parts.append(f"<p>{section['content']}</p>")

        if section.get("items"):
            html_parts.append("<ul>")
            for item in section["items"]:
                html_parts.append(f'<li class="{item.get("priority", "fyi")}">{item["content"]}</li>')
            html_parts.append("</ul>")

        html_parts.append("</section>")

    # Both signatures
    html_parts.append('<div class="signatures">')
    html_parts.append('<div class="signature-block" data-role="outgoing">')
    html_parts.append(f'<img src="{user_sig["image_base64"]}" alt="User signature"/>')
    html_parts.append(f'<p>{user_sig["signer_name"]} — {user_sig["signed_at"]}</p>')
    html_parts.append('</div>')
    html_parts.append('<div class="signature-block" data-role="hod">')
    html_parts.append(f'<img src="{hod_sig["image_base64"]}" alt="HOD signature"/>')
    html_parts.append(f'<p>{hod_sig["signer_name"]} — {hod_sig["signed_at"]}</p>')
    html_parts.append('</div>')
    html_parts.append('</div>')

    html_parts.append("</body></html>")
    return "\n".join(html_parts)


def _notify_hod_for_countersign(supabase, export_id: str, yacht_id: str, user):
    """Create ledger notification for HOD users."""
    # Get HOD users for this yacht
    hod_users = supabase.table("auth_users_profiles").select(
        "id, full_name"
    ).eq("yacht_id", yacht_id).in_("role", ["hod", "captain", "manager"]).execute()

    # Create ledger entries for each HOD
    for hod in (hod_users.data or []):
        supabase.table("pms_audit_log").insert({
            "yacht_id": yacht_id,
            "entity_type": "handover_export",
            "entity_id": export_id,
            "action": "requires_countersignature",
            "change_summary": f"Handover from {user.email} requires your countersignature",
            "user_id": hod["id"],
            "metadata": {
                "submitted_by": user.id,
                "submitted_at": datetime.utcnow().isoformat()
            }
        }).execute()


def _trigger_indexing(export_id: str, yacht_id: str):
    """Trigger embedding worker to index the signed handover."""
    import requests

    # Option 1: Render deploy hook
    # requests.post("https://api.render.com/deploy/srv-d61l5rfgi27c73cc36gg?key=rYBvR7Taprs")

    # Option 2: Direct queue insertion (preferred)
    supabase = get_supabase_client()
    supabase.table("search_index_queue").insert({
        "entity_type": "handover_export",
        "entity_id": export_id,
        "yacht_id": yacht_id,
        "priority": 1,
        "status": "pending"
    }).execute()
```

### Task 2: Create Next.js API route wrappers

Create `apps/web/src/app/api/handover-export/[id]/submit/route.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createServerClient } from '@/lib/supabase/server';

export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const supabase = createServerClient();

  // Verify auth
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const body = await request.json();

  // Call Python API
  const apiResponse = await fetch(
    `${process.env.API_URL}/v1/handover/export/${params.id}/submit`,
    {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${user.id}`
      },
      body: JSON.stringify(body)
    }
  );

  if (!apiResponse.ok) {
    const error = await apiResponse.json();
    return NextResponse.json(error, { status: apiResponse.status });
  }

  return NextResponse.json(await apiResponse.json());
}
```

Create `apps/web/src/app/api/handover-export/[id]/countersign/route.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createServerClient } from '@/lib/supabase/server';

export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const supabase = createServerClient();

  // Verify auth
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  // Verify HOD role
  const { data: profile } = await supabase
    .from('auth_users_profiles')
    .select('role')
    .eq('id', user.id)
    .single();

  if (!profile || !['hod', 'captain', 'manager'].includes(profile.role)) {
    return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
  }

  const body = await request.json();

  // Call Python API
  const apiResponse = await fetch(
    `${process.env.API_URL}/v1/handover/export/${params.id}/countersign`,
    {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${user.id}`
      },
      body: JSON.stringify(body)
    }
  );

  if (!apiResponse.ok) {
    const error = await apiResponse.json();
    return NextResponse.json(error, { status: apiResponse.status });
  }

  return NextResponse.json(await apiResponse.json());
}
```

## Verification

- [ ] Python routes created at apps/api/routes/handover_export_routes.py
- [ ] GET /content returns parsed sections
- [ ] POST /save-draft saves without signature
- [ ] POST /submit stores to Bucket 2, updates status, notifies HOD
- [ ] POST /countersign completes workflow, triggers indexing
- [ ] Next.js API wrappers created
- [ ] Storage paths follow convention: handover-exports/{yacht_id}/{bucket}/{export_id}.html
