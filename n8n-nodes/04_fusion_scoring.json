{
  "parameters": {
    "jsCode": "// =============================================================================\n// FUSION SCORING\n// Ranks and scores RAG results with boosts and penalties\n// =============================================================================\n\nconst IntentType = $workflow.staticData.IntentType;\n\n/**\n * Calculate boost scores for a result\n */\nfunction calculateBoosts(result, entities, intent) {\n  const boosts = {};\n  const data = result.data || {};\n  \n  // 1. Entity match boosts\n  // Equipment match\n  if (entities.equipment && entities.equipment.length > 0) {\n    if (checkEquipmentMatch(data, entities.equipment)) {\n      boosts.equipment_match = 0.15;\n    }\n  }\n  \n  // Fault code exact match\n  if (entities.fault_codes && entities.fault_codes.length > 0) {\n    const faultCode = data.fault_code;\n    if (faultCode && entities.fault_codes.includes(faultCode)) {\n      boosts.fault_code_match = 0.20;\n    }\n  }\n  \n  // Part number exact match\n  if (entities.part_numbers && entities.part_numbers.length > 0) {\n    const partNumber = data.part_number;\n    if (partNumber && entities.part_numbers.includes(partNumber)) {\n      boosts.part_number_match = 0.20;\n    }\n  }\n  \n  // 2. Recency boost\n  const recencyBoost = calculateRecencyBoost(data);\n  if (recencyBoost > 0) {\n    boosts.recency = recencyBoost;\n  }\n  \n  // 3. Source type boost based on intent\n  const source = result.source || '';\n  \n  switch (intent) {\n    case IntentType.DIAGNOSE_FAULT:\n      if (source === 'faults') boosts.intent_source_match = 0.12;\n      else if (source === 'document_chunks') boosts.intent_source_match = 0.08;\n      else if (source === 'work_order_history') boosts.intent_source_match = 0.06;\n      break;\n      \n    case IntentType.FIND_PART:\n      if (source === 'parts') boosts.intent_source_match = 0.15;\n      break;\n      \n    case IntentType.FIND_DOCUMENT:\n      if (['document_chunks', 'global_knowledge'].includes(source)) boosts.intent_source_match = 0.10;\n      else if (source === 'emails') boosts.intent_source_match = 0.05;\n      break;\n      \n    case IntentType.CREATE_WORK_ORDER:\n      if (source === 'work_order_history') boosts.intent_source_match = 0.10;\n      else if (source === 'faults') boosts.intent_source_match = 0.08;\n      break;\n      \n    case IntentType.PREDICTIVE_REQUEST:\n      if (source === 'faults') boosts.intent_source_match = 0.10;\n      else if (source.startsWith('graph_')) boosts.intent_source_match = 0.12;\n      break;\n  }\n  \n  // 4. Metadata quality boost\n  if (data.metadata && typeof data.metadata === 'object') {\n    if (Object.keys(data.metadata).length >= 5) {\n      boosts.metadata_rich = 0.05;\n    }\n  }\n  \n  return boosts;\n}\n\n/**\n * Calculate penalty scores for a result\n */\nfunction calculatePenalties(result, entities, intent) {\n  const penalties = {};\n  const data = result.data || {};\n  \n  // 1. Mismatched equipment penalty\n  if (entities.equipment && entities.equipment.length > 0) {\n    if (!checkEquipmentMatch(data, entities.equipment) && data.equipment_id) {\n      penalties.equipment_mismatch = 0.12;\n    }\n  }\n  \n  // 2. Outdated content penalty\n  const agePenalty = calculateAgePenalty(data);\n  if (agePenalty > 0) {\n    penalties.outdated = agePenalty;\n  }\n  \n  // 3. Low-quality chunk penalty (for documents)\n  if (result.type === 'document_chunk') {\n    const text = data.text || '';\n    if (text.length < 50) {\n      penalties.short_chunk = 0.10;\n    }\n  }\n  \n  // 4. Global knowledge penalty (prefer local data)\n  if (result.is_global) {\n    penalties.global_source = 0.08;\n  }\n  \n  // 5. Graph-only penalty (prefer semantic matches)\n  if (result.source_type === 'graph' && !result.boosts?.entity_match) {\n    penalties.graph_only = 0.05;\n  }\n  \n  return penalties;\n}\n\n/**\n * Check if data matches any equipment names\n */\nfunction checkEquipmentMatch(data, equipmentNames) {\n  // Check nested equipment object\n  if (data.equipment && typeof data.equipment === 'object') {\n    const equipmentName = (data.equipment.name || '').toLowerCase();\n    for (const name of equipmentNames) {\n      if (name.toLowerCase().includes(equipmentName) || equipmentName.includes(name.toLowerCase())) {\n        return true;\n      }\n    }\n  }\n  \n  // Check flat equipment_name field\n  if (data.equipment_name) {\n    const equipmentName = String(data.equipment_name).toLowerCase();\n    for (const name of equipmentNames) {\n      if (name.toLowerCase().includes(equipmentName) || equipmentName.includes(name.toLowerCase())) {\n        return true;\n      }\n    }\n  }\n  \n  // Check text content\n  const text = String(data.text || data.description || '').toLowerCase();\n  for (const name of equipmentNames) {\n    if (text.includes(name.toLowerCase())) {\n      return true;\n    }\n  }\n  \n  return false;\n}\n\n/**\n * Calculate recency boost (0.0 to 0.10)\n */\nfunction calculateRecencyBoost(data) {\n  const timestampFields = ['detected_at', 'completed_at', 'created_at', 'sent_at', 'indexed_at'];\n  \n  for (const field of timestampFields) {\n    if (data[field]) {\n      try {\n        const timestamp = new Date(data[field]);\n        const now = new Date();\n        const daysOld = Math.floor((now - timestamp) / (1000 * 60 * 60 * 24));\n        \n        if (daysOld <= 7) return 0.10;\n        if (daysOld <= 30) return 0.06;\n        if (daysOld <= 90) return 0.03;\n      } catch (e) {\n        // Ignore parse errors\n      }\n    }\n  }\n  \n  return 0.0;\n}\n\n/**\n * Calculate age penalty (0.0 to 0.15)\n */\nfunction calculateAgePenalty(data) {\n  const timestampFields = ['detected_at', 'completed_at', 'created_at', 'indexed_at'];\n  \n  for (const field of timestampFields) {\n    if (data[field]) {\n      try {\n        const timestamp = new Date(data[field]);\n        const now = new Date();\n        const daysOld = Math.floor((now - timestamp) / (1000 * 60 * 60 * 24));\n        \n        if (daysOld > 730) return 0.15; // > 2 years\n        if (daysOld > 365) return 0.08; // > 1 year\n      } catch (e) {\n        // Ignore parse errors\n      }\n    }\n  }\n  \n  return 0.0;\n}\n\n/**\n * Calculate final fusion scores for all results\n */\nfunction calculateFusionScores(results, entities, intent, graphDiscoveredIds = new Set()) {\n  for (const result of results) {\n    // Start with base similarity\n    let score = result.similarity || 0.7;\n    \n    // Apply boosts\n    const boosts = calculateBoosts(result, entities, intent);\n    \n    // Add graph correlation boost if applicable\n    if (graphDiscoveredIds.has(result.id) && result.source_type !== 'graph') {\n      boosts.graph_correlated = 0.08;\n    }\n    \n    result.boosts = boosts;\n    for (const [_, boostValue] of Object.entries(boosts)) {\n      score += boostValue;\n    }\n    \n    // Apply penalties\n    const penalties = calculatePenalties(result, entities, intent);\n    result.penalties = penalties;\n    for (const [_, penaltyValue] of Object.entries(penalties)) {\n      score -= penaltyValue;\n    }\n    \n    // Clamp score to 0.0 - 1.0\n    result.final_score = Math.max(0.0, Math.min(1.0, score));\n  }\n  \n  // Sort by score descending\n  results.sort((a, b) => b.final_score - a.final_score);\n  \n  return results;\n}\n\n/**\n * Deduplicate results by ID and type\n */\nfunction deduplicateResults(results) {\n  const seen = new Map();\n  const sourcePriority = { 'semantic': 0, 'keyword': 1, 'graph': 2 };\n  const deduplicated = [];\n  \n  for (const result of results) {\n    const key = `${result.id}:${result.type}`;\n    \n    if (!seen.has(key)) {\n      seen.set(key, deduplicated.length);\n      deduplicated.push(result);\n    } else {\n      const existingIdx = seen.get(key);\n      const existing = deduplicated[existingIdx];\n      \n      const currentPriority = sourcePriority[result.source_type] ?? 99;\n      const existingPriority = sourcePriority[existing.source_type] ?? 99;\n      \n      if (currentPriority < existingPriority) {\n        deduplicated[existingIdx] = result;\n      } else if (currentPriority === existingPriority && (result.similarity || 0) > (existing.similarity || 0)) {\n        deduplicated[existingIdx] = result;\n      }\n    }\n  }\n  \n  return deduplicated;\n}\n\n// Store functions in static data\n$workflow.staticData.calculateFusionScores = calculateFusionScores;\n$workflow.staticData.deduplicateResults = deduplicateResults;\n$workflow.staticData.calculateBoosts = calculateBoosts;\n$workflow.staticData.calculatePenalties = calculatePenalties;\n\nreturn [{ json: { status: 'Fusion scoring functions loaded' } }];"
  },
  "name": "Fusion Scoring",
  "type": "n8n-nodes-base.code",
  "typeVersion": 2,
  "position": [660, 0]
}
