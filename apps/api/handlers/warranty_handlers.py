"""
Warranty Claims Handlers (PR #5)
=================================

Fault Lens v1 - Warranty Claims Foundation.

Actions:
- draft_warranty_claim (crew/HOD): Create draft claim
- submit_warranty_claim (HOD): Submit for approval
- approve_warranty_claim (captain/manager): Approve claim
- reject_warranty_claim (captain/manager): Reject claim

Storage: pms-warranty-docs bucket with yacht-scoped prefixes.

Email composition (prepare only): Never auto-send.
Only HOD/captain/manager can send via existing email app.
"""

from datetime import datetime, timezone
from typing import Dict, Optional, List, Any
import logging

logger = logging.getLogger(__name__)


# =============================================================================
# CONSTANTS
# =============================================================================

VALID_CLAIM_TYPES = ["repair", "replacement", "refund"]
VALID_CLAIM_STATUSES = ["draft", "submitted", "under_review", "approved", "rejected", "closed"]

# Status transitions
STATUS_TRANSITIONS = {
    "draft": ["submitted"],
    "submitted": ["under_review", "approved", "rejected"],
    "under_review": ["approved", "rejected"],
    "approved": ["closed"],
    "rejected": ["draft"],  # Can revert to draft for revision
    "closed": [],  # Terminal
}


class WarrantyHandlers:
    """
    Handlers for Warranty Claims.

    Implements Fault Lens v1 binding brief:
    - Crew/HOD can draft claims
    - HOD can submit claims
    - Captain/manager can approve/reject
    - Email composition (prepare only, never auto-send)
    """

    def __init__(self, supabase_client):
        self.db = supabase_client

    # =========================================================================
    # DRAFT WARRANTY CLAIM
    # =========================================================================

    async def draft_warranty_claim(
        self,
        yacht_id: str,
        user_id: str,
        title: str,
        description: str,
        claim_type: str = "repair",
        equipment_id: Optional[str] = None,
        fault_id: Optional[str] = None,
        vendor_id: Optional[str] = None,
        vendor_name: Optional[str] = None,
        manufacturer: Optional[str] = None,
        part_number: Optional[str] = None,
        serial_number: Optional[str] = None,
        purchase_date: Optional[str] = None,
        warranty_expiry: Optional[str] = None,
        claimed_amount: Optional[float] = None,
        currency: str = "USD",
    ) -> Dict:
        """
        Create warranty claim draft.

        Crew and HOD can create drafts.
        Claim number is auto-generated by DB trigger.
        """
        try:
            # Validate claim type
            if claim_type not in VALID_CLAIM_TYPES:
                return {
                    "status": "error",
                    "error_code": "INVALID_CLAIM_TYPE",
                    "message": f"Invalid claim type '{claim_type}'. Valid: {', '.join(VALID_CLAIM_TYPES)}",
                }

            # Validate title
            if not title or len(title.strip()) == 0:
                return {
                    "status": "error",
                    "error_code": "TITLE_REQUIRED",
                    "message": "Claim title is required",
                }

            # Validate equipment exists (if provided)
            if equipment_id:
                eq_result = self.db.table("pms_equipment").select("id, name").eq(
                    "id", equipment_id
                ).eq("yacht_id", yacht_id).maybe_single().execute()

                if not eq_result.data:
                    return {
                        "status": "error",
                        "error_code": "EQUIPMENT_NOT_FOUND",
                        "message": f"Equipment not found: {equipment_id}",
                    }

            # Validate fault exists (if provided)
            if fault_id:
                fault_result = self.db.table("pms_faults").select("id, fault_code").eq(
                    "id", fault_id
                ).eq("yacht_id", yacht_id).maybe_single().execute()

                if not fault_result.data:
                    return {
                        "status": "error",
                        "error_code": "FAULT_NOT_FOUND",
                        "message": f"Fault not found: {fault_id}",
                    }

            # Create draft
            now = datetime.now(timezone.utc).isoformat()
            claim_data = {
                "yacht_id": yacht_id,
                "title": title,
                "description": description,
                "claim_type": claim_type,
                "status": "draft",
                "equipment_id": equipment_id,
                "fault_id": fault_id,
                "vendor_id": vendor_id,
                "vendor_name": vendor_name,
                "manufacturer": manufacturer,
                "part_number": part_number,
                "serial_number": serial_number,
                "purchase_date": purchase_date,
                "warranty_expiry": warranty_expiry,
                "claimed_amount": claimed_amount,
                "currency": currency,
                "drafted_by": user_id,
                "drafted_at": now,
                "metadata": {},
                "created_at": now,
                "updated_at": now,
            }

            result = self.db.table("pms_warranty_claims").insert(claim_data).execute()

            if not result.data:
                return {
                    "status": "error",
                    "error_code": "INTERNAL_ERROR",
                    "message": "Failed to create warranty claim",
                }

            claim = result.data[0]

            # Create audit log
            await self._create_audit_log(
                yacht_id=yacht_id,
                action="draft_warranty_claim",
                entity_type="warranty_claim",
                entity_id=claim["id"],
                user_id=user_id,
                new_values={"title": title, "claim_type": claim_type},
            )

            return {
                "status": "success",
                "action": "draft_warranty_claim",
                "result": {
                    "claim_id": claim["id"],
                    "claim_number": claim.get("claim_number"),
                    "title": claim["title"],
                    "status": "draft",
                },
                "message": f"✓ Warranty claim draft created: {claim.get('claim_number')}",
            }

        except Exception as e:
            logger.error(f"draft_warranty_claim failed: {e}", exc_info=True)
            return {
                "status": "error",
                "error_code": "INTERNAL_ERROR",
                "message": str(e),
            }

    # =========================================================================
    # SUBMIT WARRANTY CLAIM
    # =========================================================================

    async def submit_warranty_claim(
        self,
        yacht_id: str,
        user_id: str,
        claim_id: str,
    ) -> Dict:
        """
        Submit warranty claim for approval.

        HOD only. Validates required fields before submission.
        """
        try:
            # Get claim
            claim_result = self.db.table("pms_warranty_claims").select(
                "*"
            ).eq("id", claim_id).eq("yacht_id", yacht_id).maybe_single().execute()

            if not claim_result.data:
                return {
                    "status": "error",
                    "error_code": "NOT_FOUND",
                    "message": f"Warranty claim not found: {claim_id}",
                }

            claim = claim_result.data
            old_status = claim.get("status")

            # Validate status transition
            if old_status != "draft":
                return {
                    "status": "error",
                    "error_code": "INVALID_STATUS",
                    "message": f"Can only submit claims with status 'draft', got '{old_status}'",
                }

            # Validate required fields for submission
            missing_fields = []
            if not claim.get("title"):
                missing_fields.append("title")
            if not claim.get("description"):
                missing_fields.append("description")
            if not claim.get("vendor_name") and not claim.get("manufacturer"):
                missing_fields.append("vendor_name or manufacturer")

            if missing_fields:
                return {
                    "status": "error",
                    "error_code": "MISSING_REQUIRED_FIELDS",
                    "message": f"Missing required fields: {', '.join(missing_fields)}",
                    "details": {"missing_fields": missing_fields},
                }

            # Update claim
            now = datetime.now(timezone.utc).isoformat()
            update_data = {
                "status": "submitted",
                "submitted_by": user_id,
                "submitted_at": now,
                "updated_at": now,
            }

            result = self.db.table("pms_warranty_claims").update(update_data).eq(
                "id", claim_id
            ).eq("yacht_id", yacht_id).execute()

            if not result.data:
                return {
                    "status": "error",
                    "error_code": "UPDATE_FAILED",
                    "message": "Failed to submit warranty claim",
                }

            # Create audit log
            await self._create_audit_log(
                yacht_id=yacht_id,
                action="submit_warranty_claim",
                entity_type="warranty_claim",
                entity_id=claim_id,
                user_id=user_id,
                old_values={"status": old_status},
                new_values={"status": "submitted"},
            )

            # Notify captain/manager
            await self._notify_claim_submitted(
                yacht_id=yacht_id,
                claim_id=claim_id,
                claim_number=claim.get("claim_number"),
                submitted_by=user_id,
            )

            return {
                "status": "success",
                "action": "submit_warranty_claim",
                "result": {
                    "claim_id": claim_id,
                    "claim_number": claim.get("claim_number"),
                    "old_status": old_status,
                    "new_status": "submitted",
                },
                "message": f"✓ Warranty claim submitted: {claim.get('claim_number')}",
            }

        except Exception as e:
            logger.error(f"submit_warranty_claim failed: {e}", exc_info=True)
            return {
                "status": "error",
                "error_code": "INTERNAL_ERROR",
                "message": str(e),
            }

    # =========================================================================
    # APPROVE WARRANTY CLAIM
    # =========================================================================

    async def approve_warranty_claim(
        self,
        yacht_id: str,
        user_id: str,
        claim_id: str,
        approved_amount: Optional[float] = None,
        notes: Optional[str] = None,
        signature: Optional[Dict] = None,
    ) -> Dict:
        """
        Approve warranty claim.

        Captain/manager only.
        """
        try:
            # Get claim
            claim_result = self.db.table("pms_warranty_claims").select(
                "*"
            ).eq("id", claim_id).eq("yacht_id", yacht_id).maybe_single().execute()

            if not claim_result.data:
                return {
                    "status": "error",
                    "error_code": "NOT_FOUND",
                    "message": f"Warranty claim not found: {claim_id}",
                }

            claim = claim_result.data
            old_status = claim.get("status")

            # Validate status transition
            if old_status not in ("submitted", "under_review"):
                return {
                    "status": "error",
                    "error_code": "INVALID_STATUS",
                    "message": f"Can only approve claims with status 'submitted' or 'under_review', got '{old_status}'",
                }

            # Update claim
            now = datetime.now(timezone.utc).isoformat()
            update_data = {
                "status": "approved",
                "approved_by": user_id,
                "approved_at": now,
                "approved_amount": approved_amount or claim.get("claimed_amount"),
                "updated_at": now,
            }

            if notes:
                metadata = claim.get("metadata") or {}
                metadata["approval_notes"] = notes
                update_data["metadata"] = metadata

            result = self.db.table("pms_warranty_claims").update(update_data).eq(
                "id", claim_id
            ).eq("yacht_id", yacht_id).execute()

            if not result.data:
                return {
                    "status": "error",
                    "error_code": "UPDATE_FAILED",
                    "message": "Failed to approve warranty claim",
                }

            # Create audit log with signature if provided
            await self._create_audit_log(
                yacht_id=yacht_id,
                action="approve_warranty_claim",
                entity_type="warranty_claim",
                entity_id=claim_id,
                user_id=user_id,
                old_values={"status": old_status},
                new_values={"status": "approved", "approved_amount": approved_amount},
                signature=signature,
            )

            # Notify HOD/drafter
            await self._notify_claim_approved(
                yacht_id=yacht_id,
                claim_id=claim_id,
                claim_number=claim.get("claim_number"),
                drafted_by=claim.get("drafted_by"),
            )

            return {
                "status": "success",
                "action": "approve_warranty_claim",
                "result": {
                    "claim_id": claim_id,
                    "claim_number": claim.get("claim_number"),
                    "old_status": old_status,
                    "new_status": "approved",
                    "approved_amount": approved_amount,
                },
                "message": f"✓ Warranty claim approved: {claim.get('claim_number')}",
            }

        except Exception as e:
            logger.error(f"approve_warranty_claim failed: {e}", exc_info=True)
            return {
                "status": "error",
                "error_code": "INTERNAL_ERROR",
                "message": str(e),
            }

    # =========================================================================
    # REJECT WARRANTY CLAIM
    # =========================================================================

    async def reject_warranty_claim(
        self,
        yacht_id: str,
        user_id: str,
        claim_id: str,
        rejection_reason: str,
        signature: Optional[Dict] = None,
    ) -> Dict:
        """
        Reject warranty claim.

        Captain/manager only. Reason is required.
        """
        try:
            if not rejection_reason or len(rejection_reason.strip()) == 0:
                return {
                    "status": "error",
                    "error_code": "REASON_REQUIRED",
                    "message": "Rejection reason is required",
                }

            # Get claim
            claim_result = self.db.table("pms_warranty_claims").select(
                "*"
            ).eq("id", claim_id).eq("yacht_id", yacht_id).maybe_single().execute()

            if not claim_result.data:
                return {
                    "status": "error",
                    "error_code": "NOT_FOUND",
                    "message": f"Warranty claim not found: {claim_id}",
                }

            claim = claim_result.data
            old_status = claim.get("status")

            # Validate status transition
            if old_status not in ("submitted", "under_review"):
                return {
                    "status": "error",
                    "error_code": "INVALID_STATUS",
                    "message": f"Can only reject claims with status 'submitted' or 'under_review', got '{old_status}'",
                }

            # Update claim
            now = datetime.now(timezone.utc).isoformat()
            update_data = {
                "status": "rejected",
                "reviewed_by": user_id,
                "reviewed_at": now,
                "rejection_reason": rejection_reason,
                "updated_at": now,
            }

            result = self.db.table("pms_warranty_claims").update(update_data).eq(
                "id", claim_id
            ).eq("yacht_id", yacht_id).execute()

            if not result.data:
                return {
                    "status": "error",
                    "error_code": "UPDATE_FAILED",
                    "message": "Failed to reject warranty claim",
                }

            # Create audit log with signature if provided
            await self._create_audit_log(
                yacht_id=yacht_id,
                action="reject_warranty_claim",
                entity_type="warranty_claim",
                entity_id=claim_id,
                user_id=user_id,
                old_values={"status": old_status},
                new_values={"status": "rejected", "rejection_reason": rejection_reason},
                signature=signature,
            )

            # Notify HOD/drafter
            await self._notify_claim_rejected(
                yacht_id=yacht_id,
                claim_id=claim_id,
                claim_number=claim.get("claim_number"),
                drafted_by=claim.get("drafted_by"),
                rejection_reason=rejection_reason,
            )

            return {
                "status": "success",
                "action": "reject_warranty_claim",
                "result": {
                    "claim_id": claim_id,
                    "claim_number": claim.get("claim_number"),
                    "old_status": old_status,
                    "new_status": "rejected",
                    "rejection_reason": rejection_reason,
                },
                "message": f"✓ Warranty claim rejected: {claim.get('claim_number')}",
            }

        except Exception as e:
            logger.error(f"reject_warranty_claim failed: {e}", exc_info=True)
            return {
                "status": "error",
                "error_code": "INTERNAL_ERROR",
                "message": str(e),
            }

    # =========================================================================
    # COMPOSE WARRANTY EMAIL
    # =========================================================================

    async def compose_warranty_email(
        self,
        yacht_id: str,
        user_id: str,
        claim_id: str,
    ) -> Dict:
        """
        Compose warranty email (prepare only).

        NEVER auto-sends. Only returns prepared email draft.
        HOD/captain/manager can then send via existing email app.
        """
        try:
            # Get claim with full details
            claim_result = self.db.table("pms_warranty_claims").select(
                "*"
            ).eq("id", claim_id).eq("yacht_id", yacht_id).maybe_single().execute()

            if not claim_result.data:
                return {
                    "status": "error",
                    "error_code": "NOT_FOUND",
                    "message": f"Warranty claim not found: {claim_id}",
                }

            claim = claim_result.data

            # Build email components
            vendor_email = claim.get("vendor_email") or f"{claim.get('vendor_name', 'vendor')}@example.com"
            subject = f"Warranty Claim {claim.get('claim_number')} - {claim.get('title')}"

            # Build body from claim details
            body = self._compose_email_body(claim)

            # Get attachments from storage
            attachments = await self._get_claim_attachments(yacht_id, claim_id)

            email_draft = {
                "to": vendor_email,
                "subject": subject,
                "body": body,
                "attachments": attachments,
            }

            # Store email draft in claim
            now = datetime.now(timezone.utc).isoformat()
            self.db.table("pms_warranty_claims").update({
                "email_draft": email_draft,
                "updated_at": now,
            }).eq("id", claim_id).eq("yacht_id", yacht_id).execute()

            return {
                "status": "success",
                "action": "compose_warranty_email",
                "result": {
                    "claim_id": claim_id,
                    "claim_number": claim.get("claim_number"),
                    "email_draft": email_draft,
                },
                "message": "✓ Email draft prepared (NOT SENT)",
                "warning": "This email has NOT been sent. Use your email app to send.",
            }

        except Exception as e:
            logger.error(f"compose_warranty_email failed: {e}", exc_info=True)
            return {
                "status": "error",
                "error_code": "INTERNAL_ERROR",
                "message": str(e),
            }

    def _compose_email_body(self, claim: Dict) -> str:
        """Compose paraphrased email body from claim details."""
        lines = [
            f"Dear {claim.get('vendor_name', 'Vendor')},",
            "",
            f"We are submitting warranty claim {claim.get('claim_number')} for the following:",
            "",
            f"**Equipment:** {claim.get('manufacturer', 'N/A')} - Part #{claim.get('part_number', 'N/A')}",
            f"**Serial Number:** {claim.get('serial_number', 'N/A')}",
            f"**Purchase Date:** {claim.get('purchase_date', 'N/A')}",
            f"**Warranty Expiry:** {claim.get('warranty_expiry', 'N/A')}",
            "",
            f"**Claim Type:** {claim.get('claim_type', 'repair').title()}",
            f"**Claimed Amount:** {claim.get('currency', 'USD')} {claim.get('claimed_amount', 'TBD')}",
            "",
            "**Description:**",
            claim.get("description", "N/A"),
            "",
            "Please review this claim and advise on next steps.",
            "",
            "Best regards,",
            "Yacht Management Team",
        ]

        return "\n".join(lines)

    async def _get_claim_attachments(
        self, yacht_id: str, claim_id: str
    ) -> List[Dict]:
        """Get attachments for warranty claim from storage."""
        try:
            # List files in the claim's storage path
            path = f"{yacht_id}/claims/{claim_id}/"

            # For now, return placeholder - actual implementation would use storage API
            return []

        except Exception as e:
            logger.warning(f"Failed to get claim attachments: {e}")
            return []

    # =========================================================================
    # HELPER METHODS
    # =========================================================================

    async def _create_audit_log(
        self,
        yacht_id: str,
        action: str,
        entity_type: str,
        entity_id: str,
        user_id: str,
        old_values: Optional[Dict] = None,
        new_values: Optional[Dict] = None,
        signature: Optional[Dict] = None,
    ) -> Optional[str]:
        """Create audit log entry."""
        try:
            audit_data = {
                "yacht_id": yacht_id,
                "action": action,
                "entity_type": entity_type,
                "entity_id": entity_id,
                "user_id": user_id,
                "old_values": old_values,
                "new_values": new_values,
                "signature": signature or {},  # INVARIANT: never None
                "metadata": {"source": "lens", "lens": "warranty"},
                "created_at": datetime.now(timezone.utc).isoformat(),
            }

            result = self.db.table("pms_audit_log").insert(audit_data).execute()

            return result.data[0]["id"] if result.data else None

        except Exception as e:
            logger.warning(f"Failed to create audit log: {e}")
            return None

    async def _notify_claim_submitted(
        self,
        yacht_id: str,
        claim_id: str,
        claim_number: str,
        submitted_by: str,
    ) -> None:
        """Notify captain/manager when claim is submitted."""
        try:
            idempotency_key = f"warranty:{claim_id}:submitted:{datetime.now(timezone.utc).date()}"

            # Notify yacht management (captain/manager)
            # In production, would look up users by role
            self.db.rpc("upsert_notification", {
                "p_yacht_id": yacht_id,
                "p_user_id": submitted_by,  # Placeholder - should notify captain/manager
                "p_notification_type": "warranty_submitted",
                "p_title": f"Warranty claim {claim_number} submitted",
                "p_body": "A warranty claim has been submitted for your approval.",
                "p_priority": "normal",
                "p_entity_type": "warranty_claim",
                "p_entity_id": claim_id,
                "p_cta_action_id": "view_warranty_claim",
                "p_cta_payload": {"claim_id": claim_id},
                "p_idempotency_key": idempotency_key,
            }).execute()

        except Exception as e:
            logger.warning(f"Failed to notify claim submitted: {e}")

    async def _notify_claim_approved(
        self,
        yacht_id: str,
        claim_id: str,
        claim_number: str,
        drafted_by: str,
    ) -> None:
        """Notify drafter when claim is approved."""
        try:
            if not drafted_by:
                return

            idempotency_key = f"warranty:{claim_id}:approved:{datetime.now(timezone.utc).date()}"

            self.db.rpc("upsert_notification", {
                "p_yacht_id": yacht_id,
                "p_user_id": drafted_by,
                "p_notification_type": "warranty_approved",
                "p_title": f"Warranty claim {claim_number} approved",
                "p_body": "Your warranty claim has been approved.",
                "p_priority": "normal",
                "p_entity_type": "warranty_claim",
                "p_entity_id": claim_id,
                "p_cta_action_id": "view_warranty_claim",
                "p_cta_payload": {"claim_id": claim_id},
                "p_idempotency_key": idempotency_key,
            }).execute()

        except Exception as e:
            logger.warning(f"Failed to notify claim approved: {e}")

    async def _notify_claim_rejected(
        self,
        yacht_id: str,
        claim_id: str,
        claim_number: str,
        drafted_by: str,
        rejection_reason: str,
    ) -> None:
        """Notify drafter when claim is rejected."""
        try:
            if not drafted_by:
                return

            idempotency_key = f"warranty:{claim_id}:rejected:{datetime.now(timezone.utc).date()}"

            self.db.rpc("upsert_notification", {
                "p_yacht_id": yacht_id,
                "p_user_id": drafted_by,
                "p_notification_type": "warranty_rejected",
                "p_title": f"Warranty claim {claim_number} rejected",
                "p_body": f"Your warranty claim was rejected: {rejection_reason[:100]}",
                "p_priority": "normal",
                "p_entity_type": "warranty_claim",
                "p_entity_id": claim_id,
                "p_cta_action_id": "view_warranty_claim",
                "p_cta_payload": {"claim_id": claim_id},
                "p_idempotency_key": idempotency_key,
            }).execute()

        except Exception as e:
            logger.warning(f"Failed to notify claim rejected: {e}")


# =============================================================================
# HANDLER REGISTRATION
# =============================================================================

def get_warranty_handlers(supabase_client) -> Dict[str, callable]:
    """Get warranty handler functions for registration."""
    handlers = WarrantyHandlers(supabase_client)

    return {
        "draft_warranty_claim": handlers.draft_warranty_claim,
        "submit_warranty_claim": handlers.submit_warranty_claim,
        "approve_warranty_claim": handlers.approve_warranty_claim,
        "reject_warranty_claim": handlers.reject_warranty_claim,
        "compose_warranty_email": handlers.compose_warranty_email,
    }


__all__ = [
    "WarrantyHandlers",
    "get_warranty_handlers",
    "VALID_CLAIM_TYPES",
    "VALID_CLAIM_STATUSES",
    "STATUS_TRANSITIONS",
]
